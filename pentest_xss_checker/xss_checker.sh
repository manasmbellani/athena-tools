#!/bin/bash
# Script takes a number of URLs and attempts to check them for XSS.
#
# A number of have tricks to check for XSS have been taken from OWASP XSS Filter Evasion Cheatsheet: 
#     https://owasp.org/www-community/xss-filter-evasion-cheatsheet
# 
# Basic Testing conducted via XSS Game AppSpot: 
#     https://xss-game.appspot.com/level1/frame?query=Test423%27%22()%3C%3E;
# 
# Input:
#     Multiple URLs, one on each line
# 
# Args:
#     verbose: This flag can be provided for debugging by setting to 1. By default, set to 0. To
#              stop, simply enter 1.
# 
# Output:
#     Vulnerable URLs, if found
# 
# Examples:
#    To check vulnerable URLs in list urls.txt, run the command:
#        cat urls.txt | ./xss_checker.sh 
# 
#    To check multiple URLs in parallel, run the command:
#        alias pparallel='parallel --will-cite -n1 --pipe '
#        cat in-urls.txt | pparallel ./xss_checker.sh 1
#


# User agent to use for testing
USER_AGENT="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36"

# Payload Prefix
PAYLOAD_PREFIX="Test423"
FUZZ_PLACEHOLDER="FUZZ"

# Print verbose/debug messages
verbose=${1:-"0"}

function get_url_wo_query_str {
    # Function gets the URL without the query string
    # 
    # Args:
    #     url: URL to parse
    # 
    # Output:
    #     URL without query string
    # 
    # Examples:
    #     To get www.google.com/test.txt from url: www.google.com/test.txt?test=1
    #         get_url_wo_query_str 'www.google.com/test.txt?test=1'
    #
    local url="${1}"

    echo "$url" | cut -d"?" -f1
    
}

function get_query_str_params_from_url { 
    # Function returns the query string parameters (including ? and =)
    # 
    # Args:
    #     url: URL to get the query string parameters
    # 
    # Output:
    #     query string parameters found, one on each line
    # 
    # Examples:
    #     To get the query string parameters from URL, www.google.com?test=1&test=2
    #         get_query_str_params_from_url "www.google.com?test=1&test=2"
    #     
    # 
    local url="${1}"
    does_contain_query_str=$(echo "$url" | grep -i "?")
    if [ ! -z "$does_contain_query_str" ]; then
        echo "$url" | cut -d"?" -f2 | tr -s "&" "\n"
    fi
}

function debug {
    # Print the debug message if verbose flag is set
    # 
    # Args:
    #     msg: Message to print
    # 
    # Output: 
    #     print output message
    # 
    # Examples:
    #     To print 'test message', 
    #         debug 'test message'
    local msg="$1"
    if [ "$verbose" == "1" ]; then
        echo -e "[*] $msg"
    fi
}

function test_url_for_xss_single_payload {
    # Check if the URL is vulnerable to XSS, by replacing the FUZZ placeholder within it with 
    # single payload payloads and seeing if the payload is reflected within response
    # 
    # Args:
    #     url_to_test: URL to test for XSS. Contains FUZZ placeholder where each payload
    #                  gets placed
    #     single_payload: Single payload to use by sub'ing in placeholder
    #
    # Outputs:
    #     Returns URL with reflected payload prepended by string "XSS in URL: " to grep
    #     within output
    #
    local url_to_test="$1"
    local payload="$2"
    
    # is payload reflected
    local is_reflected=""

    # Build a temp file to write the output
    local outfile=$(mktemp -u)

    # Make the web request to get the output
    local url_to_curl=$(echo "$url_to_test" | sed -E "s|$FUZZ_PLACEHOLDER|$payload|g")
    debug "Testing URL for reflection: $url_to_curl and writing to outfile: $outfile"
    curl -s -k -L -A "$USER_AGENT" "$url_to_curl" -o "$outfile" 2>/dev/null

    # Check if vulnerable by using regex for validation
    local regex_found=$(grep -i "$payload" "$outfile")
    if [ ! -z "$regex_found" ]; then
        # Let user know if the payload is reflected as-is somewhere within response by 
        # returning the vulnerable URL
        echo "XSS in URL: $url_to_curl"
    fi

    # Remove the output file
    rm "$outfile"
}

function test_url_for_xss {
    # Check if the URL is vulnerable to XSS, by replacing the FUZZ placeholder within it with 
    # multiple payloads and seeing if the payload is reflected within response
    # 
    # Args:
    #     url_to_test: URL to test for XSS. Contains FUZZ placeholder where each payload
    #                  gets placed
    #
    # Outputs:
    #     Returns 1 if URL is vulnerable to XSS, else return 0 prepended by string "XSS in URL: "
    #     to grep
    #
    local url_to_test="$1"

    local vulnerable_url=""
    
    # Holds ALL Vulnerable URLs
    local vulnerable_urls=""
    local payload=""

    if [ ! -z "$url_to_test" ]; then
        # Inject in the URL path itself
        payload="\">$PAYLOAD_PREFIX'\"()<>;"
        vulnerable_url=$(test_url_for_xss_single_payload "$url_to_test" "$payload" | grep -i "XSS in URL: ")
        if [ ! -z "$vulnerable_url" ]; then
            vulnerable_urls="$vulnerable_urls\n XSS in URL: $vulnerable_url"
        fi

        # Are all chars getting reflected as-is in response?
        payload="$PAYLOAD_PREFIX'\"()<>;"
        vulnerable_url=$(test_url_for_xss_single_payload "$url_to_test" "$payload" | grep -i "XSS in URL: ")
        if [ ! -z "$vulnerable_url" ]; then
            vulnerable_urls="$vulnerable_urls\n XSS in URL: $vulnerable_url"
        fi

        # "No quotes and no semicolon" XSS
        payload="$PAYLOAD_PREFIX'()<>"
        vulnerable_url=$(test_url_for_xss_single_payload "$url_to_test" "$payload"  | grep -i "XSS in URL: ")
        if [ ! -z "$vulnerable_url" ]; then
            vulnerable_urls="$vulnerable_urls\n XSS in URL: $vulnerable_url"
        fi

        # quotes, but no semicolon XSS
        payload="$PAYLOAD_PREFIX\"()<>"
        vulnerable_url=$(test_url_for_xss_single_payload "$url_to_test" "$payload" | grep -i "XSS in URL: ")
        if [ ! -z "$vulnerable_url" ]; then
            vulnerable_urls="$vulnerable_urls\n XSS in URL: $vulnerable_url"
        fi

        # "HTML entities" XSS
        payload="$PAYLOAD_PREFIX\&()<>;"
        vulnerable_url=$(test_url_for_xss_single_payload "$url_to_test" "$payload" | grep -i "XSS in URL: ")
        if [ ! -z "$vulnerable_url" ]; then
            vulnerable_urls="$vulnerable_urls\n XSS in URL: $vulnerable_url"
        fi

        # "fromCharCode" aka NoQuotes XSS
        payload="$PAYLOAD_PREFIX()<>.:"
        vulnerable_url=$(test_url_for_xss_single_payload "$url_to_test" "$payload" | grep -i "XSS in URL: ")
        if [ ! -z "$vulnerable_url" ]; then
            vulnerable_urls="$vulnerable_urls\n XSS in URL: $vulnerable_url"
        fi
    fi
    echo -e "$vulnerable_urls"
}

# Read the URLs from user to check
urls=$(cat -)

# Loop through each url provided
IFS=$'\n'
for url in $urls; do
    debug "Testing URL: $url"

    # Get the URL without query string and query params for testing
    url_wo_query_str=$(get_url_wo_query_str "$url")
    query_str_params=$(get_query_str_params_from_url "$url")
    num_query_str_params=$(echo $query_str_params | grep -c '')

    debug "Number of query string parameters for url: $url are: $num_query_str_params"
   
    # Build the url to test - by putting the payload 
    url_to_test="$url_wo_query_str/$FUZZ_PLACEHOLDER"

    # Test if the URL is vulnerable
    debug "Testing URL: $url_to_test for XSS"
    vulnerable_urls=$(test_url_for_xss "$url_to_test")
    debug "vulnerable_urls for url: $url_to_test are: $vulnerable_urls"
    is_vulnerable=$(echo -e "$vulnerable_urls" | egrep -i "XSS in URL:")
    if [ ! -z "$is_vulnerable" ]; then
        echo "[+] Found XSS Vulnerable URLs: $vulnerable_urls"
    fi

    # Loop through each query string parameter set
    IFS=$'\n'
    for query_str_param in $query_str_params; do
        
        # Only review query parameters that are not empty
        if [ ! -z "$query_str_param" ]; then

            # Get the Key from the query string set
            query_str_param_key=$(echo "$query_str_param" | cut -d"=" -f1)
            
                    
            # Replace the placeholder in a single param, and join all remaining params together
            query_str_params_sub=$(echo "$query_str_params" \
                                | sed -E "s|$query_str_param_key=.*|$query_str_param_key=$FUZZ_PLACEHOLDER|g" \
                                | tr -s "\n" "&" \
                                | sed -E "s/&//g")

            # Build the URL to test
            url_to_test="$url_wo_query_str?$query_str_params_sub"
            
            # Test if the URL is vulnerable
            vulnerable_urls=$(test_url_for_xss "$url_to_test")
            is_vulnerable=$(echo -e "$vulnerable_urls" | egrep -i "XSS in URL: ")
            if [ ! -z "$is_vulnerable" ]; then
                echo "[+] Found XSS Vulnerable URLs: $vulnerable_urls"
            fi
        fi

    done
done
