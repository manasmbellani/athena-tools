#!/usr/bin/env python3
#
#
# This script will check the output of command `uname -sr` run on device and
# determine if there are any exploits applicable for this device.
# 
# 
import argparse
import json
import os
import re
import sys

DESCRIPTION = """
Description
-----------
This script will check the output of command `uname -sr` run on device and
determine if there are any exploits applicable for this device.
"""

def get_dict_value_for_key(dict_to_check, keys_to_check, default_val="",
                           lower_case=False):
    """Get first key from a dictionary that is not null
    
    Arguments
    ---------
    dict_to_check: Dictionary to check
    keys_to_check: List of key values to check
    default_val: Default value to return if value not found. By default, ''
    lower_case: The case of returned values is converted to lower, if this flag
        is set. By default, False.

    Returns
    -------
    default_val, if value not found, else
    value defined for the specified key
    """
    dict_val = default_val
    for key in keys_to_check:
        if key in dict_to_check:
            dict_val = dict_to_check[key]
            if lower_case:
                if isinstance(dict_val, str):
                    dict_val = dict_val.lower()
                elif isinstance(dict_val, list):
                    dict_val = [val.lower() for val in dict_val]
                elif isinstance(dict_val, dict):
                    dict_val = {k.lower():v.lower() for k,v in dict_val.items()}

    return dict_val

def split_versions(version_to_check):
    versions = version_to_check.split(".")
    versions_len = len(versions)
    major_version = versions[0]
    if versions_len >= 2:
        minor_version = versions[1]
    else:
        minor_version = ""
    if versions_len >= 3:
        sub_minor_version = versions[2]
    else:
        sub_minor_version = ""
    
    return (major_version, minor_version, sub_minor_version)

def compare_single_version(a_version, lower_a_version, higher_a_version=""):
    if a_version:
        if lower_a_version:
            if higher_a_version:
                if int(lower_a_version) <= int(a_version) <= int(higher_a_version):
                    return True
                else:
                    return False
            else:
                if int(lower_a_version) == int(a_version):
                    return True
                else:
                    return False
        else:
            if higher_a_version:
                if int(a_version) <= int(higher_a_version):
                    return True
                else:
                    return False
            else:
                return True
    else:
        return True
        #raise ValueError("No single version (major/minor) specified.")

def compare_versions(version_to_check, lower_version, higher_version=""):
    params = {'version_to_check': version_to_check,
              'lower_version': lower_version,
              'higher_version': higher_version}


    print("[*] Comparing version: {version_to_check} to "
                 "lower_version: {lower_version} and "
                 "higher version: {higher_version}".format(**params))

    (major_version,
     minor_version,
     sub_minor_version) = split_versions(version_to_check)
    (major_lower_version,
     minor_lower_version,
     sub_minor_lower_version) = split_versions(lower_version)
    if higher_version:
        (major_higher_version,
         minor_higher_version,
         sub_minor_higher_version) = split_versions(higher_version)
    else:
        minor_higher_version = major_higher_version = sub_minor_higher_version = ""

    is_version_matching = False

    if compare_single_version(major_version, major_lower_version, major_higher_version):
        if compare_single_version(minor_version, minor_lower_version, minor_higher_version):
            if compare_single_version(sub_minor_version, sub_minor_lower_version, sub_minor_higher_version):
                is_version_matching = True

    return is_version_matching

def compare_names(kernel_os_name_to_check, kernel_os_name_to_match):
    return kernel_os_name_to_check.lower() == kernel_os_name_to_match.lower()

def compare_exploit(exploit_id, exploit_json, kernel_name, kernel_version, 
                    os_name='', os_version=''):


    applicable_kernels = get_dict_value_for_key(exploit_json,
                                                ['kernel',
                                                 'kernels'], 
                                                {})
    applicable_oss = get_dict_value_for_key(exploit_json,
                                            ['os', 'OS'],
                                            {})
    
    if kernel_name and kernel_version:
        for applicable_kernel_name, applicable_kernel_config in applicable_kernels.items():
            if compare_names(applicable_kernel_name, kernel_name):
                applicable_versions = get_dict_value_for_key(applicable_kernel_config, ['version',
                                                                                         'versions',
                                                                                         'affected_versions'
                                                                                         'affected_version'])
                for applicable_version in applicable_versions:
                    if isinstance(applicable_version, dict):
                        lower_applicable_version = applicable_version['lower']
                        higher_applicable_version = applicable_version['higher']
                        if compare_versions(kernel_version, lower_applicable_version, higher_applicable_version):
                            msg_to_send = ("Found valid exploit: {} with "
                                           "kernel name: {}, versions: [{}, {}] for target "
                                           "with name/version: {}, {}".format(exploit_id,
                                                                         applicable_kernel_name,
                                                                         lower_applicable_version,
                                                                         higher_applicable_version,
                                                                         kernel_name,
                                                                         kernel_version))
                            print("[+] " + msg_to_send)
                            return True
                    elif isinstance(applicable_version, int) or isinstance(applicable_version, str):
                        if compare_versions(kernel_version, applicable_version):
                            msg_to_send = ("Found valid exploit: {} with "
                                           "kernel name: {}, version: {} for target "
                                           "with name/version: {}, {}".format(exploit_id,
                                                                         applicable_kernel_name,
                                                                         applicable_version,
                                                                         kernel_name,
                                                                         kernel_version))
                            print("[+] " + msg_to_send)
                            return True
     
    if os_name and os_version:
        for applicable_os_name, applicable_os_config in applicable_oss.items():
            if compare_names(applicable_os_name, os_name):
                applicable_versions = get_dict_value_for_key(applicable_os_config, ['version',
                                                                                    'versions',
                                                                                    'affected_versions'
                                                                                    'affected_version'])
                for applicable_version in applicable_versions:
                    if isinstance(applicable_version, dict):
                        lower_applicable_version = applicable_version['lower']
                        higher_applicable_version = applicable_version['higher']
                        if compare_versions(os_version, lower_applicable_version, higher_applicable_version):
                            msg_to_send = ("Found valid exploit: {} with "
                                           "OS name: {}, versions: [{}, {}] for target"
                                           "with version: {}, {}".format(exploit_id,
                                                                         applicable_os_name,                     
                                                                         lower_applicable_version,
                                                                         higher_applicable_version,
                                                                         os_name,
                                                                         os_version))
                            print("[+] " + msg_to_send)
                            return True
                    elif isinstance(applicable_version, int) or isinstance(applicable_version, str):
                        if compare_versions(os_version, applicable_version):
                            msg_to_send = ("Found valid exploit: {} with "
                                           "OS name: {}, versions: [{}] for target "
                                           "with version: {}, {}".format(exploit_id,
                                                                         applicable_os_name,
                                                                         applicable_version,
                                                                         os_name,
                                                                         os_version))
                            print("[+] " + msg_to_send)
                            return True
           
def run_all_exploit_checks(exploits_json, kernel_name, kernel_version, os_name='', os_version=''):

    for exploit_id, exploit_json in exploits_json.items():
        print("[*] Running check for exploit id: {}".format(exploit_id))    
        compare_exploit(exploit_id, exploit_json, kernel_name, kernel_version,
                        os_name, os_version)


def test():
    assert (compare_versions("19.2", "19.2") == True)
    assert (compare_versions("19.2", "19.2.1") == True)
    assert (compare_versions("19.2.2", "19.2.3", "19.2.5") == False)
    assert (compare_versions("19.2.4", "19.2.3", "19.2.5") == True)
    assert (compare_versions("19.2.0", "19.2.1", "19.2.5") == False)
    assert (compare_versions("19.2.4", "18", "20") == True)

   
def main():
    parser = argparse.ArgumentParser(description=DESCRIPTION)
    parser.add_argument("-ui", "--uname-sr", required=True,
                        help="String with `uname -sr` input")
    parser.add_argument("-os", "--os-name-version",
                        help="OS version e.g. Ubuntu 10.04, Darwin 6")
    parser.add_argument("-ef", "--exploits-file", 
                        default="linux_kernel_exploits.json",
                        help="File with exploits & applicable versions")
    params = vars(parser.parse_args())

    print("[*] Logger obtained...")
    
    print("[*] Checking if exploits_file: {exploits_file} exists".format(**params))
    if not os.path.isfile(params['exploits_file']):
        print("[-] File: {exploits_file} not found.")
        return 1

    print("[*] Reading JSON exploits_file: {exploits_file}".format(**params))
    with open(params['exploits_file'], "r+") as f:
        exploits_json = json.load(f)

    print("[*] Extract the kernel type from `uname -sr` input")
    reg = "(?P<kernel_name>[a-zA-Z0-9\-]+) [^ 0-9\.]*(?P<kernel_version>[0-9\.]+)"
    m = re.search(reg, params['uname_sr'], re.I)
    if m:
        kernel_name = params['kernel_name'] = m.group('kernel_name')
        kernel_version = params['kernel_version'] = m.group('kernel_version')
        print("[+] kernel_name: {kernel_name}, kernel_version: {kernel_version}".format(**params))
    else:
        print("[-] kernel name/version could not be obtained from uname")
        return 1

    print("[*] Getting the OS name and version")
    if params['os_name_version']:
        os_name = params['os_name'] = params['os_name_version'].split(" ")[0] 
        os_version = params['os_version'] = params['os_name_version'].split(" ")[1] 
        print("[+] os_name: {os_name}, os_version: {os_version}".format(**params))
    else:
        print("[!] os_name/version not specified")

    print("[*] Running checks through all the exploits")
    run_all_exploit_checks(exploits_json,
                           kernel_name,
                           kernel_version,
                           os_name,
                           os_version)

if __name__ == "__main__":
    sys.exit(main())
    #sys.exit(test())

