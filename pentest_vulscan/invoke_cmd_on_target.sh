#!/bin/bash
#
# Invoke a command on the specified target, port, protocol which is substitued
# within the given command
# 
# If no regex specified, then the command's output is just written to STDOUT 
# as-is. Otherwise, the 
# 
# 

# Directory to create temporary names
TEMP_DIR="/tmp/out-invoke-cmd-tmpfiles"

# Delimiter to use
DELIM="|"

if [ $# -lt 1 ]; then
    echo "[-] ...<target/port/protocol>... | $0 <cmd> [regex_filter] \
[verbose=1]"
    exit 1
fi
cmd="$1"
regex_filter="$2"
verbose=${3:-"0"}

# Get the current directory
script_dir=$(dirname "$0")

# Read input lines
lines=$(cat -)

IFS=$'\n'
for line in $lines; do

    if [ ! -z "$line" ]; then
        target=$(echo "$line" | $script_dir/get_target_combo_parts.sh 'target')
        port=$(echo "$line" | $script_dir/get_target_combo_parts.sh 'port')
        protocol=$(echo "$line" | $script_dir/get_target_combo_parts.sh \
            'protocol')
        

        # Command to replace
        cmd_to_exec="$cmd"
        cmd_to_exec=$(echo "$cmd_to_exec" | sed -E "s|TARGET|$target|g")
        cmd_to_exec=$(echo "$cmd_to_exec" | sed -E "s|PORT|$port|g")
        cmd_to_exec=$(echo "$cmd_to_exec" | sed -E "s|PROTOCOL|$protocol|g")

        # Print the command to be executed
        [ "$verbose" == "1" ] && echo "[*] Invoking command: $cmd_to_exec"

        # Make the web request
        cmd_out=$(/bin/bash -c "$cmd_to_exec")

        # Write output to a file if verbose mode set
        if [ "$verbose" == "1" ]; then

            # Create the output folder for temporary files
            [ ! -d "$TEMP_DIR" ] && mkdir "$TEMP_DIR"

            # Start Store the output files here
            outfile_raw="$(mktemp -u)"
            outfile_basename=$(basename "$outfile_raw")
            outfile=$(echo "$TEMP_DIR/$outfile_basename")
            echo "$cmd_out" > "$outfile"
            echo "[*] Output for cmd: $cmd_to_exec written to outfile: $outfile"
        fi

        # Put the entire request into a single line
        cmd_out_one_line=$(echo "$cmd_out" | tr -s "\r\n" "$DELIM")

        if [ ! -z "$regex_filter" ] && [ "$regex_filter" != "NONE" ] && \
            [ "$regex_filter" != "none" ]; then

            [ "$verbose" == "1" ] && echo "[*] Match output for cmd: $cmd_to_exec \
to filter: $regex_filter"

            # Check if it matches filter - if it does, print the URL out
            resp_matches=$(echo "$cmd_out_one_line" \
                | grep -iE "$regex_filter")
            
            # If response matching regex, then print command run
            if [ ! -z "$resp_matches" ]; then
                [ "$verbose" == "1" ] && echo "[+] Match found for cmd: $cmd_to_exec \
with filter: $regex_filter"
                echo "$cmd"
            fi
        else
            # Writing output for the given command
            echo "$cmd_out"
        fi
    fi
done