#!/bin/bash
#
# Invoke a command on the specified target, port, protocol which is substitued
# within the given command
# 
# If no regex specified, then the command's output is just written to STDOUT 
# as-is. Otherwise, the 
# 
# 

DELIM="|"

if [ $# -lt 1 ]; then
    echo "[-] ...<target/port/protocol>... | $0 <cmd> [regex_filter]"
    exit 1
fi
cmd="$1"
regex_filter="$2"

# Get the current directory
script_dir=$(dirname "$0")

# Read input lines
lines=$(cat -)

IFS=$'\n'
for line in $lines; do

    if [ ! -z "$line" ]; then
        target=$(echo "$line" | $script_dir/get_target_combo_parts.sh 'target')
        port=$(echo "$line" | $script_dir/get_target_combo_parts.sh 'port')
        protocol=$(echo "$line" | $script_dir/get_target_combo_parts.sh \
            'protocol')
        

        # Command to replace
        cmd_to_exec="$cmd"
        cmd_to_exec=$(echo "$cmd_to_exec" | sed -E "s|TARGET|$target|g")
        cmd_to_exec=$(echo "$cmd_to_exec" | sed -E "s|PORT|$port|g")
        cmd_to_exec=$(echo "$cmd_to_exec" | sed -E "s|PROTOCOL|$protocol|g")

        # Make the web request
        cmd_out=$(/bin/bash -c "$cmd_to_exec")

        # Put the entire request into a single line
        cmd_out_one_line=$(echo "$cmd_out" | tr -s "\r\n" "$DELIM")

        if [ ! -z "$regex_filter" ]; then

            # Check if it matches filter - if it does, print the URL out
            resp_matches=$(echo "$cmd_out_one_line" \
                | grep -iE "$regex_filter")
            
            # If response matching regex, then print command run
            if [ ! -z "$resp_matches" ]; then
                echo "$cmd"
            fi
        else
            # Writing output for the given command
            echo "$cmd_out"
        fi
    fi
done