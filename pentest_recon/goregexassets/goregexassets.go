// Golang tool to extract asssets such as domains, emails, IPs from single file,
// folder OR list of files and writes to the specific output file
package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
)

// Find takes a slice and looks for an element in it. If found it will
// return it's key, otherwise it will return -1 and a bool of false.
func Find(slice []string, val string) (int, bool) {
	for i, item := range slice {
		if item == val {
			return i, true
		}
	}
	return -1, false
}

// Regex patterns for IP, domains and email addresses
const RegexIP = "[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}"
const RegexDomain = "([a-zA-Z0-9_-]+\\.)+[a-zA-Z0-9_-]{1,6}"
const RegexEmail = "[a-zA-Z0-9_-]+@([a-zA-Z0-9_-]+\\.)+[a-zA-Z0-9]{1,6}"

func main() {
	pathsToParse := flag.String("paths", "",
		"files/folder paths from which to extract assets")
	assetType := flag.String("assetType", "",
		"Asset type to extract. Can be one of: email, ip, domain, all")
	flag.Parse()

	if *pathsToParse == "" {
		log.Fatalln("[-] Files for assets to parse must be provided.")
	}

	// Convert the comma-sep list of files, folders to loop through
	pathsToCheck := strings.Split(*pathsToParse, ",")

	// List of all files in the folders/files above
	var filesToParse []string

	// Loop through each path and attempt to discover all files
	for _, pathToCheck := range pathsToCheck {

		//Check if paths exist
		fi, err := os.Stat(pathToCheck)
		if err != nil {
			fmt.Fprintf(os.Stderr, "[-] Path: %s not found\n", pathToCheck)
		} else {

			switch mode := fi.Mode(); {

			// Add all files from the directory
			case mode.IsDir():

				filepath.Walk(pathToCheck,
					func(path string, f os.FileInfo, err error) error {

						// Determine if the path is actually a file
						fi, err := os.Stat(path)
						if fi.Mode().IsRegular() == true {

							// Add the path if it doesn't already exist to list
							// of all files
							_, found := Find(filesToParse, path)
							if !found {
								filesToParse = append(filesToParse, path)
							}
						}
						return nil
					})

			// Add a single file, if not already present
			case mode.IsRegular():

				// Add the path if it doesn't already exist to list
				// of all files
				_, found := Find(filesToParse, pathToCheck)
				if !found {
					filesToParse = append(filesToParse, pathToCheck)
				}
			}
		}
	}

	// List of all emails, domains, IPs
	var emails []string
	var domains []string
	var ips []string

	var wg sync.WaitGroup

	// Start look through each file path now, and add assets if not found
	for _, filepath := range filesToParse {

		if filepath != "" {
			wg.Add(1)
			go func() {
				defer wg.Done()

				bincontent, err := ioutil.ReadFile(filepath)
				fileContent := string(bincontent)
				if err != nil {
					log.Fatalf("[-] Can't read file: %s\n", filepath)
				}

				if *assetType == "all" || *assetType == "email" {
					regexEmail, _ := regexp.Compile(RegexEmail)
					emails = regexEmail.FindAllString(fileContent, -1)
					for _, email := range emails {
						fmt.Println(email)
					}
				}

				if *assetType == "all" || *assetType == "ip" {
					regexIP, _ := regexp.Compile(RegexIP)
					ips = regexIP.FindAllString(fileContent, -1)
					for _, ip := range ips {
						fmt.Println(ip)
					}
				}

				if *assetType == "all" || *assetType == "domain" {
					regexDomain, _ := regexp.Compile(RegexDomain)
					domains = regexDomain.FindAllString(fileContent, -1)
					for _, domain := range domains {
						fmt.Println(domain)
					}
				}
			}()
		}
	}
	wg.Wait()
}
